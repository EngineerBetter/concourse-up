// Code generated by counterfeiter. DO NOT EDIT.
package iaasfakes

import (
	"sync"

	"github.com/EngineerBetter/concourse-up/iaas"
)

type FakeIClient struct {
	DeleteFileStub        func(bucket, path string) error
	deleteFileMutex       sync.RWMutex
	deleteFileArgsForCall []struct {
		bucket string
		path   string
	}
	deleteFileReturns struct {
		result1 error
	}
	deleteFileReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVersionedBucketStub        func(name string) error
	deleteVersionedBucketMutex       sync.RWMutex
	deleteVersionedBucketArgsForCall []struct {
		name string
	}
	deleteVersionedBucketReturns struct {
		result1 error
	}
	deleteVersionedBucketReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVMsInVPCStub        func(vpcID string) error
	deleteVMsInVPCMutex       sync.RWMutex
	deleteVMsInVPCArgsForCall []struct {
		vpcID string
	}
	deleteVMsInVPCReturns struct {
		result1 error
	}
	deleteVMsInVPCReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureBucketExistsStub        func(name string) error
	ensureBucketExistsMutex       sync.RWMutex
	ensureBucketExistsArgsForCall []struct {
		name string
	}
	ensureBucketExistsReturns struct {
		result1 error
	}
	ensureBucketExistsReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureFileExistsStub        func(bucket, path string, defaultContents []byte) ([]byte, bool, error)
	ensureFileExistsMutex       sync.RWMutex
	ensureFileExistsArgsForCall []struct {
		bucket          string
		path            string
		defaultContents []byte
	}
	ensureFileExistsReturns struct {
		result1 []byte
		result2 bool
		result3 error
	}
	ensureFileExistsReturnsOnCall map[int]struct {
		result1 []byte
		result2 bool
		result3 error
	}
	NewRoute53ClientStub        func() (iaas.Route53, error)
	newRoute53ClientMutex       sync.RWMutex
	newRoute53ClientArgsForCall []struct{}
	newRoute53ClientReturns     struct {
		result1 iaas.Route53
		result2 error
	}
	newRoute53ClientReturnsOnCall map[int]struct {
		result1 iaas.Route53
		result2 error
	}
	FindLongestMatchingHostedZoneStub        func(subDomain string, route53Client iaas.Route53) (string, string, error)
	findLongestMatchingHostedZoneMutex       sync.RWMutex
	findLongestMatchingHostedZoneArgsForCall []struct {
		subDomain     string
		route53Client iaas.Route53
	}
	findLongestMatchingHostedZoneReturns struct {
		result1 string
		result2 string
		result3 error
	}
	findLongestMatchingHostedZoneReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	HasFileStub        func(bucket, path string) (bool, error)
	hasFileMutex       sync.RWMutex
	hasFileArgsForCall []struct {
		bucket string
		path   string
	}
	hasFileReturns struct {
		result1 bool
		result2 error
	}
	hasFileReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	LoadFileStub        func(bucket, path string) ([]byte, error)
	loadFileMutex       sync.RWMutex
	loadFileArgsForCall []struct {
		bucket string
		path   string
	}
	loadFileReturns struct {
		result1 []byte
		result2 error
	}
	loadFileReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	WriteFileStub        func(bucket, path string, contents []byte) error
	writeFileMutex       sync.RWMutex
	writeFileArgsForCall []struct {
		bucket   string
		path     string
		contents []byte
	}
	writeFileReturns struct {
		result1 error
	}
	writeFileReturnsOnCall map[int]struct {
		result1 error
	}
	RegionStub        func() string
	regionMutex       sync.RWMutex
	regionArgsForCall []struct{}
	regionReturns     struct {
		result1 string
	}
	regionReturnsOnCall map[int]struct {
		result1 string
	}
	IAASStub        func() string
	iAASMutex       sync.RWMutex
	iAASArgsForCall []struct{}
	iAASReturns     struct {
		result1 string
	}
	iAASReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIClient) DeleteFile(bucket string, path string) error {
	fake.deleteFileMutex.Lock()
	ret, specificReturn := fake.deleteFileReturnsOnCall[len(fake.deleteFileArgsForCall)]
	fake.deleteFileArgsForCall = append(fake.deleteFileArgsForCall, struct {
		bucket string
		path   string
	}{bucket, path})
	fake.recordInvocation("DeleteFile", []interface{}{bucket, path})
	fake.deleteFileMutex.Unlock()
	if fake.DeleteFileStub != nil {
		return fake.DeleteFileStub(bucket, path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteFileReturns.result1
}

func (fake *FakeIClient) DeleteFileCallCount() int {
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	return len(fake.deleteFileArgsForCall)
}

func (fake *FakeIClient) DeleteFileArgsForCall(i int) (string, string) {
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	return fake.deleteFileArgsForCall[i].bucket, fake.deleteFileArgsForCall[i].path
}

func (fake *FakeIClient) DeleteFileReturns(result1 error) {
	fake.DeleteFileStub = nil
	fake.deleteFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteFileReturnsOnCall(i int, result1 error) {
	fake.DeleteFileStub = nil
	if fake.deleteFileReturnsOnCall == nil {
		fake.deleteFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteVersionedBucket(name string) error {
	fake.deleteVersionedBucketMutex.Lock()
	ret, specificReturn := fake.deleteVersionedBucketReturnsOnCall[len(fake.deleteVersionedBucketArgsForCall)]
	fake.deleteVersionedBucketArgsForCall = append(fake.deleteVersionedBucketArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("DeleteVersionedBucket", []interface{}{name})
	fake.deleteVersionedBucketMutex.Unlock()
	if fake.DeleteVersionedBucketStub != nil {
		return fake.DeleteVersionedBucketStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteVersionedBucketReturns.result1
}

func (fake *FakeIClient) DeleteVersionedBucketCallCount() int {
	fake.deleteVersionedBucketMutex.RLock()
	defer fake.deleteVersionedBucketMutex.RUnlock()
	return len(fake.deleteVersionedBucketArgsForCall)
}

func (fake *FakeIClient) DeleteVersionedBucketArgsForCall(i int) string {
	fake.deleteVersionedBucketMutex.RLock()
	defer fake.deleteVersionedBucketMutex.RUnlock()
	return fake.deleteVersionedBucketArgsForCall[i].name
}

func (fake *FakeIClient) DeleteVersionedBucketReturns(result1 error) {
	fake.DeleteVersionedBucketStub = nil
	fake.deleteVersionedBucketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteVersionedBucketReturnsOnCall(i int, result1 error) {
	fake.DeleteVersionedBucketStub = nil
	if fake.deleteVersionedBucketReturnsOnCall == nil {
		fake.deleteVersionedBucketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVersionedBucketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteVMsInVPC(vpcID string) error {
	fake.deleteVMsInVPCMutex.Lock()
	ret, specificReturn := fake.deleteVMsInVPCReturnsOnCall[len(fake.deleteVMsInVPCArgsForCall)]
	fake.deleteVMsInVPCArgsForCall = append(fake.deleteVMsInVPCArgsForCall, struct {
		vpcID string
	}{vpcID})
	fake.recordInvocation("DeleteVMsInVPC", []interface{}{vpcID})
	fake.deleteVMsInVPCMutex.Unlock()
	if fake.DeleteVMsInVPCStub != nil {
		return fake.DeleteVMsInVPCStub(vpcID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteVMsInVPCReturns.result1
}

func (fake *FakeIClient) DeleteVMsInVPCCallCount() int {
	fake.deleteVMsInVPCMutex.RLock()
	defer fake.deleteVMsInVPCMutex.RUnlock()
	return len(fake.deleteVMsInVPCArgsForCall)
}

func (fake *FakeIClient) DeleteVMsInVPCArgsForCall(i int) string {
	fake.deleteVMsInVPCMutex.RLock()
	defer fake.deleteVMsInVPCMutex.RUnlock()
	return fake.deleteVMsInVPCArgsForCall[i].vpcID
}

func (fake *FakeIClient) DeleteVMsInVPCReturns(result1 error) {
	fake.DeleteVMsInVPCStub = nil
	fake.deleteVMsInVPCReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteVMsInVPCReturnsOnCall(i int, result1 error) {
	fake.DeleteVMsInVPCStub = nil
	if fake.deleteVMsInVPCReturnsOnCall == nil {
		fake.deleteVMsInVPCReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVMsInVPCReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) EnsureBucketExists(name string) error {
	fake.ensureBucketExistsMutex.Lock()
	ret, specificReturn := fake.ensureBucketExistsReturnsOnCall[len(fake.ensureBucketExistsArgsForCall)]
	fake.ensureBucketExistsArgsForCall = append(fake.ensureBucketExistsArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("EnsureBucketExists", []interface{}{name})
	fake.ensureBucketExistsMutex.Unlock()
	if fake.EnsureBucketExistsStub != nil {
		return fake.EnsureBucketExistsStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ensureBucketExistsReturns.result1
}

func (fake *FakeIClient) EnsureBucketExistsCallCount() int {
	fake.ensureBucketExistsMutex.RLock()
	defer fake.ensureBucketExistsMutex.RUnlock()
	return len(fake.ensureBucketExistsArgsForCall)
}

func (fake *FakeIClient) EnsureBucketExistsArgsForCall(i int) string {
	fake.ensureBucketExistsMutex.RLock()
	defer fake.ensureBucketExistsMutex.RUnlock()
	return fake.ensureBucketExistsArgsForCall[i].name
}

func (fake *FakeIClient) EnsureBucketExistsReturns(result1 error) {
	fake.EnsureBucketExistsStub = nil
	fake.ensureBucketExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) EnsureBucketExistsReturnsOnCall(i int, result1 error) {
	fake.EnsureBucketExistsStub = nil
	if fake.ensureBucketExistsReturnsOnCall == nil {
		fake.ensureBucketExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureBucketExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) EnsureFileExists(bucket string, path string, defaultContents []byte) ([]byte, bool, error) {
	var defaultContentsCopy []byte
	if defaultContents != nil {
		defaultContentsCopy = make([]byte, len(defaultContents))
		copy(defaultContentsCopy, defaultContents)
	}
	fake.ensureFileExistsMutex.Lock()
	ret, specificReturn := fake.ensureFileExistsReturnsOnCall[len(fake.ensureFileExistsArgsForCall)]
	fake.ensureFileExistsArgsForCall = append(fake.ensureFileExistsArgsForCall, struct {
		bucket          string
		path            string
		defaultContents []byte
	}{bucket, path, defaultContentsCopy})
	fake.recordInvocation("EnsureFileExists", []interface{}{bucket, path, defaultContentsCopy})
	fake.ensureFileExistsMutex.Unlock()
	if fake.EnsureFileExistsStub != nil {
		return fake.EnsureFileExistsStub(bucket, path, defaultContents)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.ensureFileExistsReturns.result1, fake.ensureFileExistsReturns.result2, fake.ensureFileExistsReturns.result3
}

func (fake *FakeIClient) EnsureFileExistsCallCount() int {
	fake.ensureFileExistsMutex.RLock()
	defer fake.ensureFileExistsMutex.RUnlock()
	return len(fake.ensureFileExistsArgsForCall)
}

func (fake *FakeIClient) EnsureFileExistsArgsForCall(i int) (string, string, []byte) {
	fake.ensureFileExistsMutex.RLock()
	defer fake.ensureFileExistsMutex.RUnlock()
	return fake.ensureFileExistsArgsForCall[i].bucket, fake.ensureFileExistsArgsForCall[i].path, fake.ensureFileExistsArgsForCall[i].defaultContents
}

func (fake *FakeIClient) EnsureFileExistsReturns(result1 []byte, result2 bool, result3 error) {
	fake.EnsureFileExistsStub = nil
	fake.ensureFileExistsReturns = struct {
		result1 []byte
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIClient) EnsureFileExistsReturnsOnCall(i int, result1 []byte, result2 bool, result3 error) {
	fake.EnsureFileExistsStub = nil
	if fake.ensureFileExistsReturnsOnCall == nil {
		fake.ensureFileExistsReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 bool
			result3 error
		})
	}
	fake.ensureFileExistsReturnsOnCall[i] = struct {
		result1 []byte
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIClient) NewRoute53Client() (iaas.Route53, error) {
	fake.newRoute53ClientMutex.Lock()
	ret, specificReturn := fake.newRoute53ClientReturnsOnCall[len(fake.newRoute53ClientArgsForCall)]
	fake.newRoute53ClientArgsForCall = append(fake.newRoute53ClientArgsForCall, struct{}{})
	fake.recordInvocation("NewRoute53Client", []interface{}{})
	fake.newRoute53ClientMutex.Unlock()
	if fake.NewRoute53ClientStub != nil {
		return fake.NewRoute53ClientStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.newRoute53ClientReturns.result1, fake.newRoute53ClientReturns.result2
}

func (fake *FakeIClient) NewRoute53ClientCallCount() int {
	fake.newRoute53ClientMutex.RLock()
	defer fake.newRoute53ClientMutex.RUnlock()
	return len(fake.newRoute53ClientArgsForCall)
}

func (fake *FakeIClient) NewRoute53ClientReturns(result1 iaas.Route53, result2 error) {
	fake.NewRoute53ClientStub = nil
	fake.newRoute53ClientReturns = struct {
		result1 iaas.Route53
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) NewRoute53ClientReturnsOnCall(i int, result1 iaas.Route53, result2 error) {
	fake.NewRoute53ClientStub = nil
	if fake.newRoute53ClientReturnsOnCall == nil {
		fake.newRoute53ClientReturnsOnCall = make(map[int]struct {
			result1 iaas.Route53
			result2 error
		})
	}
	fake.newRoute53ClientReturnsOnCall[i] = struct {
		result1 iaas.Route53
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) FindLongestMatchingHostedZone(subDomain string, route53Client iaas.Route53) (string, string, error) {
	fake.findLongestMatchingHostedZoneMutex.Lock()
	ret, specificReturn := fake.findLongestMatchingHostedZoneReturnsOnCall[len(fake.findLongestMatchingHostedZoneArgsForCall)]
	fake.findLongestMatchingHostedZoneArgsForCall = append(fake.findLongestMatchingHostedZoneArgsForCall, struct {
		subDomain     string
		route53Client iaas.Route53
	}{subDomain, route53Client})
	fake.recordInvocation("FindLongestMatchingHostedZone", []interface{}{subDomain, route53Client})
	fake.findLongestMatchingHostedZoneMutex.Unlock()
	if fake.FindLongestMatchingHostedZoneStub != nil {
		return fake.FindLongestMatchingHostedZoneStub(subDomain, route53Client)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findLongestMatchingHostedZoneReturns.result1, fake.findLongestMatchingHostedZoneReturns.result2, fake.findLongestMatchingHostedZoneReturns.result3
}

func (fake *FakeIClient) FindLongestMatchingHostedZoneCallCount() int {
	fake.findLongestMatchingHostedZoneMutex.RLock()
	defer fake.findLongestMatchingHostedZoneMutex.RUnlock()
	return len(fake.findLongestMatchingHostedZoneArgsForCall)
}

func (fake *FakeIClient) FindLongestMatchingHostedZoneArgsForCall(i int) (string, iaas.Route53) {
	fake.findLongestMatchingHostedZoneMutex.RLock()
	defer fake.findLongestMatchingHostedZoneMutex.RUnlock()
	return fake.findLongestMatchingHostedZoneArgsForCall[i].subDomain, fake.findLongestMatchingHostedZoneArgsForCall[i].route53Client
}

func (fake *FakeIClient) FindLongestMatchingHostedZoneReturns(result1 string, result2 string, result3 error) {
	fake.FindLongestMatchingHostedZoneStub = nil
	fake.findLongestMatchingHostedZoneReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIClient) FindLongestMatchingHostedZoneReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.FindLongestMatchingHostedZoneStub = nil
	if fake.findLongestMatchingHostedZoneReturnsOnCall == nil {
		fake.findLongestMatchingHostedZoneReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.findLongestMatchingHostedZoneReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIClient) HasFile(bucket string, path string) (bool, error) {
	fake.hasFileMutex.Lock()
	ret, specificReturn := fake.hasFileReturnsOnCall[len(fake.hasFileArgsForCall)]
	fake.hasFileArgsForCall = append(fake.hasFileArgsForCall, struct {
		bucket string
		path   string
	}{bucket, path})
	fake.recordInvocation("HasFile", []interface{}{bucket, path})
	fake.hasFileMutex.Unlock()
	if fake.HasFileStub != nil {
		return fake.HasFileStub(bucket, path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hasFileReturns.result1, fake.hasFileReturns.result2
}

func (fake *FakeIClient) HasFileCallCount() int {
	fake.hasFileMutex.RLock()
	defer fake.hasFileMutex.RUnlock()
	return len(fake.hasFileArgsForCall)
}

func (fake *FakeIClient) HasFileArgsForCall(i int) (string, string) {
	fake.hasFileMutex.RLock()
	defer fake.hasFileMutex.RUnlock()
	return fake.hasFileArgsForCall[i].bucket, fake.hasFileArgsForCall[i].path
}

func (fake *FakeIClient) HasFileReturns(result1 bool, result2 error) {
	fake.HasFileStub = nil
	fake.hasFileReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) HasFileReturnsOnCall(i int, result1 bool, result2 error) {
	fake.HasFileStub = nil
	if fake.hasFileReturnsOnCall == nil {
		fake.hasFileReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasFileReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) LoadFile(bucket string, path string) ([]byte, error) {
	fake.loadFileMutex.Lock()
	ret, specificReturn := fake.loadFileReturnsOnCall[len(fake.loadFileArgsForCall)]
	fake.loadFileArgsForCall = append(fake.loadFileArgsForCall, struct {
		bucket string
		path   string
	}{bucket, path})
	fake.recordInvocation("LoadFile", []interface{}{bucket, path})
	fake.loadFileMutex.Unlock()
	if fake.LoadFileStub != nil {
		return fake.LoadFileStub(bucket, path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.loadFileReturns.result1, fake.loadFileReturns.result2
}

func (fake *FakeIClient) LoadFileCallCount() int {
	fake.loadFileMutex.RLock()
	defer fake.loadFileMutex.RUnlock()
	return len(fake.loadFileArgsForCall)
}

func (fake *FakeIClient) LoadFileArgsForCall(i int) (string, string) {
	fake.loadFileMutex.RLock()
	defer fake.loadFileMutex.RUnlock()
	return fake.loadFileArgsForCall[i].bucket, fake.loadFileArgsForCall[i].path
}

func (fake *FakeIClient) LoadFileReturns(result1 []byte, result2 error) {
	fake.LoadFileStub = nil
	fake.loadFileReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) LoadFileReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.LoadFileStub = nil
	if fake.loadFileReturnsOnCall == nil {
		fake.loadFileReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.loadFileReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) WriteFile(bucket string, path string, contents []byte) error {
	var contentsCopy []byte
	if contents != nil {
		contentsCopy = make([]byte, len(contents))
		copy(contentsCopy, contents)
	}
	fake.writeFileMutex.Lock()
	ret, specificReturn := fake.writeFileReturnsOnCall[len(fake.writeFileArgsForCall)]
	fake.writeFileArgsForCall = append(fake.writeFileArgsForCall, struct {
		bucket   string
		path     string
		contents []byte
	}{bucket, path, contentsCopy})
	fake.recordInvocation("WriteFile", []interface{}{bucket, path, contentsCopy})
	fake.writeFileMutex.Unlock()
	if fake.WriteFileStub != nil {
		return fake.WriteFileStub(bucket, path, contents)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.writeFileReturns.result1
}

func (fake *FakeIClient) WriteFileCallCount() int {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	return len(fake.writeFileArgsForCall)
}

func (fake *FakeIClient) WriteFileArgsForCall(i int) (string, string, []byte) {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	return fake.writeFileArgsForCall[i].bucket, fake.writeFileArgsForCall[i].path, fake.writeFileArgsForCall[i].contents
}

func (fake *FakeIClient) WriteFileReturns(result1 error) {
	fake.WriteFileStub = nil
	fake.writeFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) WriteFileReturnsOnCall(i int, result1 error) {
	fake.WriteFileStub = nil
	if fake.writeFileReturnsOnCall == nil {
		fake.writeFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) Region() string {
	fake.regionMutex.Lock()
	ret, specificReturn := fake.regionReturnsOnCall[len(fake.regionArgsForCall)]
	fake.regionArgsForCall = append(fake.regionArgsForCall, struct{}{})
	fake.recordInvocation("Region", []interface{}{})
	fake.regionMutex.Unlock()
	if fake.RegionStub != nil {
		return fake.RegionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.regionReturns.result1
}

func (fake *FakeIClient) RegionCallCount() int {
	fake.regionMutex.RLock()
	defer fake.regionMutex.RUnlock()
	return len(fake.regionArgsForCall)
}

func (fake *FakeIClient) RegionReturns(result1 string) {
	fake.RegionStub = nil
	fake.regionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIClient) RegionReturnsOnCall(i int, result1 string) {
	fake.RegionStub = nil
	if fake.regionReturnsOnCall == nil {
		fake.regionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.regionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIClient) IAAS() string {
	fake.iAASMutex.Lock()
	ret, specificReturn := fake.iAASReturnsOnCall[len(fake.iAASArgsForCall)]
	fake.iAASArgsForCall = append(fake.iAASArgsForCall, struct{}{})
	fake.recordInvocation("IAAS", []interface{}{})
	fake.iAASMutex.Unlock()
	if fake.IAASStub != nil {
		return fake.IAASStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iAASReturns.result1
}

func (fake *FakeIClient) IAASCallCount() int {
	fake.iAASMutex.RLock()
	defer fake.iAASMutex.RUnlock()
	return len(fake.iAASArgsForCall)
}

func (fake *FakeIClient) IAASReturns(result1 string) {
	fake.IAASStub = nil
	fake.iAASReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIClient) IAASReturnsOnCall(i int, result1 string) {
	fake.IAASStub = nil
	if fake.iAASReturnsOnCall == nil {
		fake.iAASReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iAASReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	fake.deleteVersionedBucketMutex.RLock()
	defer fake.deleteVersionedBucketMutex.RUnlock()
	fake.deleteVMsInVPCMutex.RLock()
	defer fake.deleteVMsInVPCMutex.RUnlock()
	fake.ensureBucketExistsMutex.RLock()
	defer fake.ensureBucketExistsMutex.RUnlock()
	fake.ensureFileExistsMutex.RLock()
	defer fake.ensureFileExistsMutex.RUnlock()
	fake.newRoute53ClientMutex.RLock()
	defer fake.newRoute53ClientMutex.RUnlock()
	fake.findLongestMatchingHostedZoneMutex.RLock()
	defer fake.findLongestMatchingHostedZoneMutex.RUnlock()
	fake.hasFileMutex.RLock()
	defer fake.hasFileMutex.RUnlock()
	fake.loadFileMutex.RLock()
	defer fake.loadFileMutex.RUnlock()
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	fake.regionMutex.RLock()
	defer fake.regionMutex.RUnlock()
	fake.iAASMutex.RLock()
	defer fake.iAASMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ iaas.IClient = new(FakeIClient)
