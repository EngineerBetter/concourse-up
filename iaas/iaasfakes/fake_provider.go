// Code generated by counterfeiter. DO NOT EDIT.
package iaasfakes

import (
	"sync"

	"github.com/EngineerBetter/concourse-up/iaas"
)

type FakeProvider struct {
	AttrStub        func(string) (string, error)
	attrMutex       sync.RWMutex
	attrArgsForCall []struct {
		arg1 string
	}
	attrReturns struct {
		result1 string
		result2 error
	}
	attrReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	BucketExistsStub        func(string) (bool, error)
	bucketExistsMutex       sync.RWMutex
	bucketExistsArgsForCall []struct {
		arg1 string
	}
	bucketExistsReturns struct {
		result1 bool
		result2 error
	}
	bucketExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CheckForWhitelistedIPStub        func(string, string) (bool, error)
	checkForWhitelistedIPMutex       sync.RWMutex
	checkForWhitelistedIPArgsForCall []struct {
		arg1 string
		arg2 string
	}
	checkForWhitelistedIPReturns struct {
		result1 bool
		result2 error
	}
	checkForWhitelistedIPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ChooseStub        func(iaas.Choice) interface{}
	chooseMutex       sync.RWMutex
	chooseArgsForCall []struct {
		arg1 iaas.Choice
	}
	chooseReturns struct {
		result1 interface{}
	}
	chooseReturnsOnCall map[int]struct {
		result1 interface{}
	}
	CreateBucketStub        func(string) error
	createBucketMutex       sync.RWMutex
	createBucketArgsForCall []struct {
		arg1 string
	}
	createBucketReturns struct {
		result1 error
	}
	createBucketReturnsOnCall map[int]struct {
		result1 error
	}
	CreateDatabasesStub        func(string, string, string) error
	createDatabasesMutex       sync.RWMutex
	createDatabasesArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	createDatabasesReturns struct {
		result1 error
	}
	createDatabasesReturnsOnCall map[int]struct {
		result1 error
	}
	DBTypeStub        func(string) string
	dBTypeMutex       sync.RWMutex
	dBTypeArgsForCall []struct {
		arg1 string
	}
	dBTypeReturns struct {
		result1 string
	}
	dBTypeReturnsOnCall map[int]struct {
		result1 string
	}
	DeleteFileStub        func(string, string) error
	deleteFileMutex       sync.RWMutex
	deleteFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteFileReturns struct {
		result1 error
	}
	deleteFileReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVMsInDeploymentStub        func(string, string, string) error
	deleteVMsInDeploymentMutex       sync.RWMutex
	deleteVMsInDeploymentArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	deleteVMsInDeploymentReturns struct {
		result1 error
	}
	deleteVMsInDeploymentReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVMsInVPCStub        func(string) ([]string, error)
	deleteVMsInVPCMutex       sync.RWMutex
	deleteVMsInVPCArgsForCall []struct {
		arg1 string
	}
	deleteVMsInVPCReturns struct {
		result1 []string
		result2 error
	}
	deleteVMsInVPCReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	DeleteVersionedBucketStub        func(string) error
	deleteVersionedBucketMutex       sync.RWMutex
	deleteVersionedBucketArgsForCall []struct {
		arg1 string
	}
	deleteVersionedBucketReturns struct {
		result1 error
	}
	deleteVersionedBucketReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVolumesStub        func([]string, func(ec2Client iaas.IEC2, volumeID *string) error) error
	deleteVolumesMutex       sync.RWMutex
	deleteVolumesArgsForCall []struct {
		arg1 []string
		arg2 func(ec2Client iaas.IEC2, volumeID *string) error
	}
	deleteVolumesReturns struct {
		result1 error
	}
	deleteVolumesReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureFileExistsStub        func(string, string, []byte) ([]byte, bool, error)
	ensureFileExistsMutex       sync.RWMutex
	ensureFileExistsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []byte
	}
	ensureFileExistsReturns struct {
		result1 []byte
		result2 bool
		result3 error
	}
	ensureFileExistsReturnsOnCall map[int]struct {
		result1 []byte
		result2 bool
		result3 error
	}
	FindLongestMatchingHostedZoneStub        func(string) (string, string, error)
	findLongestMatchingHostedZoneMutex       sync.RWMutex
	findLongestMatchingHostedZoneArgsForCall []struct {
		arg1 string
	}
	findLongestMatchingHostedZoneReturns struct {
		result1 string
		result2 string
		result3 error
	}
	findLongestMatchingHostedZoneReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	HasFileStub        func(string, string) (bool, error)
	hasFileMutex       sync.RWMutex
	hasFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	hasFileReturns struct {
		result1 bool
		result2 error
	}
	hasFileReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IAASStub        func() iaas.Name
	iAASMutex       sync.RWMutex
	iAASArgsForCall []struct {
	}
	iAASReturns struct {
		result1 iaas.Name
	}
	iAASReturnsOnCall map[int]struct {
		result1 iaas.Name
	}
	LoadFileStub        func(string, string) ([]byte, error)
	loadFileMutex       sync.RWMutex
	loadFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	loadFileReturns struct {
		result1 []byte
		result2 error
	}
	loadFileReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	RegionStub        func() string
	regionMutex       sync.RWMutex
	regionArgsForCall []struct {
	}
	regionReturns struct {
		result1 string
	}
	regionReturnsOnCall map[int]struct {
		result1 string
	}
	WorkerTypeStub        func(string)
	workerTypeMutex       sync.RWMutex
	workerTypeArgsForCall []struct {
		arg1 string
	}
	WriteFileStub        func(string, string, []byte) error
	writeFileMutex       sync.RWMutex
	writeFileArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []byte
	}
	writeFileReturns struct {
		result1 error
	}
	writeFileReturnsOnCall map[int]struct {
		result1 error
	}
	ZoneStub        func(string) string
	zoneMutex       sync.RWMutex
	zoneArgsForCall []struct {
		arg1 string
	}
	zoneReturns struct {
		result1 string
	}
	zoneReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeProvider) Attr(arg1 string) (string, error) {
	fake.attrMutex.Lock()
	ret, specificReturn := fake.attrReturnsOnCall[len(fake.attrArgsForCall)]
	fake.attrArgsForCall = append(fake.attrArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Attr", []interface{}{arg1})
	fake.attrMutex.Unlock()
	if fake.AttrStub != nil {
		return fake.AttrStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.attrReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeProvider) AttrCallCount() int {
	fake.attrMutex.RLock()
	defer fake.attrMutex.RUnlock()
	return len(fake.attrArgsForCall)
}

func (fake *FakeProvider) AttrCalls(stub func(string) (string, error)) {
	fake.attrMutex.Lock()
	defer fake.attrMutex.Unlock()
	fake.AttrStub = stub
}

func (fake *FakeProvider) AttrArgsForCall(i int) string {
	fake.attrMutex.RLock()
	defer fake.attrMutex.RUnlock()
	argsForCall := fake.attrArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProvider) AttrReturns(result1 string, result2 error) {
	fake.attrMutex.Lock()
	defer fake.attrMutex.Unlock()
	fake.AttrStub = nil
	fake.attrReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) AttrReturnsOnCall(i int, result1 string, result2 error) {
	fake.attrMutex.Lock()
	defer fake.attrMutex.Unlock()
	fake.AttrStub = nil
	if fake.attrReturnsOnCall == nil {
		fake.attrReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.attrReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) BucketExists(arg1 string) (bool, error) {
	fake.bucketExistsMutex.Lock()
	ret, specificReturn := fake.bucketExistsReturnsOnCall[len(fake.bucketExistsArgsForCall)]
	fake.bucketExistsArgsForCall = append(fake.bucketExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("BucketExists", []interface{}{arg1})
	fake.bucketExistsMutex.Unlock()
	if fake.BucketExistsStub != nil {
		return fake.BucketExistsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.bucketExistsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeProvider) BucketExistsCallCount() int {
	fake.bucketExistsMutex.RLock()
	defer fake.bucketExistsMutex.RUnlock()
	return len(fake.bucketExistsArgsForCall)
}

func (fake *FakeProvider) BucketExistsCalls(stub func(string) (bool, error)) {
	fake.bucketExistsMutex.Lock()
	defer fake.bucketExistsMutex.Unlock()
	fake.BucketExistsStub = stub
}

func (fake *FakeProvider) BucketExistsArgsForCall(i int) string {
	fake.bucketExistsMutex.RLock()
	defer fake.bucketExistsMutex.RUnlock()
	argsForCall := fake.bucketExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProvider) BucketExistsReturns(result1 bool, result2 error) {
	fake.bucketExistsMutex.Lock()
	defer fake.bucketExistsMutex.Unlock()
	fake.BucketExistsStub = nil
	fake.bucketExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) BucketExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.bucketExistsMutex.Lock()
	defer fake.bucketExistsMutex.Unlock()
	fake.BucketExistsStub = nil
	if fake.bucketExistsReturnsOnCall == nil {
		fake.bucketExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.bucketExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) CheckForWhitelistedIP(arg1 string, arg2 string) (bool, error) {
	fake.checkForWhitelistedIPMutex.Lock()
	ret, specificReturn := fake.checkForWhitelistedIPReturnsOnCall[len(fake.checkForWhitelistedIPArgsForCall)]
	fake.checkForWhitelistedIPArgsForCall = append(fake.checkForWhitelistedIPArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CheckForWhitelistedIP", []interface{}{arg1, arg2})
	fake.checkForWhitelistedIPMutex.Unlock()
	if fake.CheckForWhitelistedIPStub != nil {
		return fake.CheckForWhitelistedIPStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.checkForWhitelistedIPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeProvider) CheckForWhitelistedIPCallCount() int {
	fake.checkForWhitelistedIPMutex.RLock()
	defer fake.checkForWhitelistedIPMutex.RUnlock()
	return len(fake.checkForWhitelistedIPArgsForCall)
}

func (fake *FakeProvider) CheckForWhitelistedIPCalls(stub func(string, string) (bool, error)) {
	fake.checkForWhitelistedIPMutex.Lock()
	defer fake.checkForWhitelistedIPMutex.Unlock()
	fake.CheckForWhitelistedIPStub = stub
}

func (fake *FakeProvider) CheckForWhitelistedIPArgsForCall(i int) (string, string) {
	fake.checkForWhitelistedIPMutex.RLock()
	defer fake.checkForWhitelistedIPMutex.RUnlock()
	argsForCall := fake.checkForWhitelistedIPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeProvider) CheckForWhitelistedIPReturns(result1 bool, result2 error) {
	fake.checkForWhitelistedIPMutex.Lock()
	defer fake.checkForWhitelistedIPMutex.Unlock()
	fake.CheckForWhitelistedIPStub = nil
	fake.checkForWhitelistedIPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) CheckForWhitelistedIPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkForWhitelistedIPMutex.Lock()
	defer fake.checkForWhitelistedIPMutex.Unlock()
	fake.CheckForWhitelistedIPStub = nil
	if fake.checkForWhitelistedIPReturnsOnCall == nil {
		fake.checkForWhitelistedIPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkForWhitelistedIPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) Choose(arg1 iaas.Choice) interface{} {
	fake.chooseMutex.Lock()
	ret, specificReturn := fake.chooseReturnsOnCall[len(fake.chooseArgsForCall)]
	fake.chooseArgsForCall = append(fake.chooseArgsForCall, struct {
		arg1 iaas.Choice
	}{arg1})
	fake.recordInvocation("Choose", []interface{}{arg1})
	fake.chooseMutex.Unlock()
	if fake.ChooseStub != nil {
		return fake.ChooseStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.chooseReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) ChooseCallCount() int {
	fake.chooseMutex.RLock()
	defer fake.chooseMutex.RUnlock()
	return len(fake.chooseArgsForCall)
}

func (fake *FakeProvider) ChooseCalls(stub func(iaas.Choice) interface{}) {
	fake.chooseMutex.Lock()
	defer fake.chooseMutex.Unlock()
	fake.ChooseStub = stub
}

func (fake *FakeProvider) ChooseArgsForCall(i int) iaas.Choice {
	fake.chooseMutex.RLock()
	defer fake.chooseMutex.RUnlock()
	argsForCall := fake.chooseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProvider) ChooseReturns(result1 interface{}) {
	fake.chooseMutex.Lock()
	defer fake.chooseMutex.Unlock()
	fake.ChooseStub = nil
	fake.chooseReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeProvider) ChooseReturnsOnCall(i int, result1 interface{}) {
	fake.chooseMutex.Lock()
	defer fake.chooseMutex.Unlock()
	fake.ChooseStub = nil
	if fake.chooseReturnsOnCall == nil {
		fake.chooseReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.chooseReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeProvider) CreateBucket(arg1 string) error {
	fake.createBucketMutex.Lock()
	ret, specificReturn := fake.createBucketReturnsOnCall[len(fake.createBucketArgsForCall)]
	fake.createBucketArgsForCall = append(fake.createBucketArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CreateBucket", []interface{}{arg1})
	fake.createBucketMutex.Unlock()
	if fake.CreateBucketStub != nil {
		return fake.CreateBucketStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createBucketReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) CreateBucketCallCount() int {
	fake.createBucketMutex.RLock()
	defer fake.createBucketMutex.RUnlock()
	return len(fake.createBucketArgsForCall)
}

func (fake *FakeProvider) CreateBucketCalls(stub func(string) error) {
	fake.createBucketMutex.Lock()
	defer fake.createBucketMutex.Unlock()
	fake.CreateBucketStub = stub
}

func (fake *FakeProvider) CreateBucketArgsForCall(i int) string {
	fake.createBucketMutex.RLock()
	defer fake.createBucketMutex.RUnlock()
	argsForCall := fake.createBucketArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProvider) CreateBucketReturns(result1 error) {
	fake.createBucketMutex.Lock()
	defer fake.createBucketMutex.Unlock()
	fake.CreateBucketStub = nil
	fake.createBucketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) CreateBucketReturnsOnCall(i int, result1 error) {
	fake.createBucketMutex.Lock()
	defer fake.createBucketMutex.Unlock()
	fake.CreateBucketStub = nil
	if fake.createBucketReturnsOnCall == nil {
		fake.createBucketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createBucketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) CreateDatabases(arg1 string, arg2 string, arg3 string) error {
	fake.createDatabasesMutex.Lock()
	ret, specificReturn := fake.createDatabasesReturnsOnCall[len(fake.createDatabasesArgsForCall)]
	fake.createDatabasesArgsForCall = append(fake.createDatabasesArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("CreateDatabases", []interface{}{arg1, arg2, arg3})
	fake.createDatabasesMutex.Unlock()
	if fake.CreateDatabasesStub != nil {
		return fake.CreateDatabasesStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createDatabasesReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) CreateDatabasesCallCount() int {
	fake.createDatabasesMutex.RLock()
	defer fake.createDatabasesMutex.RUnlock()
	return len(fake.createDatabasesArgsForCall)
}

func (fake *FakeProvider) CreateDatabasesCalls(stub func(string, string, string) error) {
	fake.createDatabasesMutex.Lock()
	defer fake.createDatabasesMutex.Unlock()
	fake.CreateDatabasesStub = stub
}

func (fake *FakeProvider) CreateDatabasesArgsForCall(i int) (string, string, string) {
	fake.createDatabasesMutex.RLock()
	defer fake.createDatabasesMutex.RUnlock()
	argsForCall := fake.createDatabasesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeProvider) CreateDatabasesReturns(result1 error) {
	fake.createDatabasesMutex.Lock()
	defer fake.createDatabasesMutex.Unlock()
	fake.CreateDatabasesStub = nil
	fake.createDatabasesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) CreateDatabasesReturnsOnCall(i int, result1 error) {
	fake.createDatabasesMutex.Lock()
	defer fake.createDatabasesMutex.Unlock()
	fake.CreateDatabasesStub = nil
	if fake.createDatabasesReturnsOnCall == nil {
		fake.createDatabasesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createDatabasesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) DBType(arg1 string) string {
	fake.dBTypeMutex.Lock()
	ret, specificReturn := fake.dBTypeReturnsOnCall[len(fake.dBTypeArgsForCall)]
	fake.dBTypeArgsForCall = append(fake.dBTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DBType", []interface{}{arg1})
	fake.dBTypeMutex.Unlock()
	if fake.DBTypeStub != nil {
		return fake.DBTypeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dBTypeReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) DBTypeCallCount() int {
	fake.dBTypeMutex.RLock()
	defer fake.dBTypeMutex.RUnlock()
	return len(fake.dBTypeArgsForCall)
}

func (fake *FakeProvider) DBTypeCalls(stub func(string) string) {
	fake.dBTypeMutex.Lock()
	defer fake.dBTypeMutex.Unlock()
	fake.DBTypeStub = stub
}

func (fake *FakeProvider) DBTypeArgsForCall(i int) string {
	fake.dBTypeMutex.RLock()
	defer fake.dBTypeMutex.RUnlock()
	argsForCall := fake.dBTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProvider) DBTypeReturns(result1 string) {
	fake.dBTypeMutex.Lock()
	defer fake.dBTypeMutex.Unlock()
	fake.DBTypeStub = nil
	fake.dBTypeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeProvider) DBTypeReturnsOnCall(i int, result1 string) {
	fake.dBTypeMutex.Lock()
	defer fake.dBTypeMutex.Unlock()
	fake.DBTypeStub = nil
	if fake.dBTypeReturnsOnCall == nil {
		fake.dBTypeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.dBTypeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeProvider) DeleteFile(arg1 string, arg2 string) error {
	fake.deleteFileMutex.Lock()
	ret, specificReturn := fake.deleteFileReturnsOnCall[len(fake.deleteFileArgsForCall)]
	fake.deleteFileArgsForCall = append(fake.deleteFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("DeleteFile", []interface{}{arg1, arg2})
	fake.deleteFileMutex.Unlock()
	if fake.DeleteFileStub != nil {
		return fake.DeleteFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteFileReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) DeleteFileCallCount() int {
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	return len(fake.deleteFileArgsForCall)
}

func (fake *FakeProvider) DeleteFileCalls(stub func(string, string) error) {
	fake.deleteFileMutex.Lock()
	defer fake.deleteFileMutex.Unlock()
	fake.DeleteFileStub = stub
}

func (fake *FakeProvider) DeleteFileArgsForCall(i int) (string, string) {
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	argsForCall := fake.deleteFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeProvider) DeleteFileReturns(result1 error) {
	fake.deleteFileMutex.Lock()
	defer fake.deleteFileMutex.Unlock()
	fake.DeleteFileStub = nil
	fake.deleteFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) DeleteFileReturnsOnCall(i int, result1 error) {
	fake.deleteFileMutex.Lock()
	defer fake.deleteFileMutex.Unlock()
	fake.DeleteFileStub = nil
	if fake.deleteFileReturnsOnCall == nil {
		fake.deleteFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) DeleteVMsInDeployment(arg1 string, arg2 string, arg3 string) error {
	fake.deleteVMsInDeploymentMutex.Lock()
	ret, specificReturn := fake.deleteVMsInDeploymentReturnsOnCall[len(fake.deleteVMsInDeploymentArgsForCall)]
	fake.deleteVMsInDeploymentArgsForCall = append(fake.deleteVMsInDeploymentArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("DeleteVMsInDeployment", []interface{}{arg1, arg2, arg3})
	fake.deleteVMsInDeploymentMutex.Unlock()
	if fake.DeleteVMsInDeploymentStub != nil {
		return fake.DeleteVMsInDeploymentStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteVMsInDeploymentReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) DeleteVMsInDeploymentCallCount() int {
	fake.deleteVMsInDeploymentMutex.RLock()
	defer fake.deleteVMsInDeploymentMutex.RUnlock()
	return len(fake.deleteVMsInDeploymentArgsForCall)
}

func (fake *FakeProvider) DeleteVMsInDeploymentCalls(stub func(string, string, string) error) {
	fake.deleteVMsInDeploymentMutex.Lock()
	defer fake.deleteVMsInDeploymentMutex.Unlock()
	fake.DeleteVMsInDeploymentStub = stub
}

func (fake *FakeProvider) DeleteVMsInDeploymentArgsForCall(i int) (string, string, string) {
	fake.deleteVMsInDeploymentMutex.RLock()
	defer fake.deleteVMsInDeploymentMutex.RUnlock()
	argsForCall := fake.deleteVMsInDeploymentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeProvider) DeleteVMsInDeploymentReturns(result1 error) {
	fake.deleteVMsInDeploymentMutex.Lock()
	defer fake.deleteVMsInDeploymentMutex.Unlock()
	fake.DeleteVMsInDeploymentStub = nil
	fake.deleteVMsInDeploymentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) DeleteVMsInDeploymentReturnsOnCall(i int, result1 error) {
	fake.deleteVMsInDeploymentMutex.Lock()
	defer fake.deleteVMsInDeploymentMutex.Unlock()
	fake.DeleteVMsInDeploymentStub = nil
	if fake.deleteVMsInDeploymentReturnsOnCall == nil {
		fake.deleteVMsInDeploymentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVMsInDeploymentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) DeleteVMsInVPC(arg1 string) ([]string, error) {
	fake.deleteVMsInVPCMutex.Lock()
	ret, specificReturn := fake.deleteVMsInVPCReturnsOnCall[len(fake.deleteVMsInVPCArgsForCall)]
	fake.deleteVMsInVPCArgsForCall = append(fake.deleteVMsInVPCArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteVMsInVPC", []interface{}{arg1})
	fake.deleteVMsInVPCMutex.Unlock()
	if fake.DeleteVMsInVPCStub != nil {
		return fake.DeleteVMsInVPCStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteVMsInVPCReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeProvider) DeleteVMsInVPCCallCount() int {
	fake.deleteVMsInVPCMutex.RLock()
	defer fake.deleteVMsInVPCMutex.RUnlock()
	return len(fake.deleteVMsInVPCArgsForCall)
}

func (fake *FakeProvider) DeleteVMsInVPCCalls(stub func(string) ([]string, error)) {
	fake.deleteVMsInVPCMutex.Lock()
	defer fake.deleteVMsInVPCMutex.Unlock()
	fake.DeleteVMsInVPCStub = stub
}

func (fake *FakeProvider) DeleteVMsInVPCArgsForCall(i int) string {
	fake.deleteVMsInVPCMutex.RLock()
	defer fake.deleteVMsInVPCMutex.RUnlock()
	argsForCall := fake.deleteVMsInVPCArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProvider) DeleteVMsInVPCReturns(result1 []string, result2 error) {
	fake.deleteVMsInVPCMutex.Lock()
	defer fake.deleteVMsInVPCMutex.Unlock()
	fake.DeleteVMsInVPCStub = nil
	fake.deleteVMsInVPCReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) DeleteVMsInVPCReturnsOnCall(i int, result1 []string, result2 error) {
	fake.deleteVMsInVPCMutex.Lock()
	defer fake.deleteVMsInVPCMutex.Unlock()
	fake.DeleteVMsInVPCStub = nil
	if fake.deleteVMsInVPCReturnsOnCall == nil {
		fake.deleteVMsInVPCReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.deleteVMsInVPCReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) DeleteVersionedBucket(arg1 string) error {
	fake.deleteVersionedBucketMutex.Lock()
	ret, specificReturn := fake.deleteVersionedBucketReturnsOnCall[len(fake.deleteVersionedBucketArgsForCall)]
	fake.deleteVersionedBucketArgsForCall = append(fake.deleteVersionedBucketArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteVersionedBucket", []interface{}{arg1})
	fake.deleteVersionedBucketMutex.Unlock()
	if fake.DeleteVersionedBucketStub != nil {
		return fake.DeleteVersionedBucketStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteVersionedBucketReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) DeleteVersionedBucketCallCount() int {
	fake.deleteVersionedBucketMutex.RLock()
	defer fake.deleteVersionedBucketMutex.RUnlock()
	return len(fake.deleteVersionedBucketArgsForCall)
}

func (fake *FakeProvider) DeleteVersionedBucketCalls(stub func(string) error) {
	fake.deleteVersionedBucketMutex.Lock()
	defer fake.deleteVersionedBucketMutex.Unlock()
	fake.DeleteVersionedBucketStub = stub
}

func (fake *FakeProvider) DeleteVersionedBucketArgsForCall(i int) string {
	fake.deleteVersionedBucketMutex.RLock()
	defer fake.deleteVersionedBucketMutex.RUnlock()
	argsForCall := fake.deleteVersionedBucketArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProvider) DeleteVersionedBucketReturns(result1 error) {
	fake.deleteVersionedBucketMutex.Lock()
	defer fake.deleteVersionedBucketMutex.Unlock()
	fake.DeleteVersionedBucketStub = nil
	fake.deleteVersionedBucketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) DeleteVersionedBucketReturnsOnCall(i int, result1 error) {
	fake.deleteVersionedBucketMutex.Lock()
	defer fake.deleteVersionedBucketMutex.Unlock()
	fake.DeleteVersionedBucketStub = nil
	if fake.deleteVersionedBucketReturnsOnCall == nil {
		fake.deleteVersionedBucketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVersionedBucketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) DeleteVolumes(arg1 []string, arg2 func(ec2Client iaas.IEC2, volumeID *string) error) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deleteVolumesMutex.Lock()
	ret, specificReturn := fake.deleteVolumesReturnsOnCall[len(fake.deleteVolumesArgsForCall)]
	fake.deleteVolumesArgsForCall = append(fake.deleteVolumesArgsForCall, struct {
		arg1 []string
		arg2 func(ec2Client iaas.IEC2, volumeID *string) error
	}{arg1Copy, arg2})
	fake.recordInvocation("DeleteVolumes", []interface{}{arg1Copy, arg2})
	fake.deleteVolumesMutex.Unlock()
	if fake.DeleteVolumesStub != nil {
		return fake.DeleteVolumesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteVolumesReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) DeleteVolumesCallCount() int {
	fake.deleteVolumesMutex.RLock()
	defer fake.deleteVolumesMutex.RUnlock()
	return len(fake.deleteVolumesArgsForCall)
}

func (fake *FakeProvider) DeleteVolumesCalls(stub func([]string, func(ec2Client iaas.IEC2, volumeID *string) error) error) {
	fake.deleteVolumesMutex.Lock()
	defer fake.deleteVolumesMutex.Unlock()
	fake.DeleteVolumesStub = stub
}

func (fake *FakeProvider) DeleteVolumesArgsForCall(i int) ([]string, func(ec2Client iaas.IEC2, volumeID *string) error) {
	fake.deleteVolumesMutex.RLock()
	defer fake.deleteVolumesMutex.RUnlock()
	argsForCall := fake.deleteVolumesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeProvider) DeleteVolumesReturns(result1 error) {
	fake.deleteVolumesMutex.Lock()
	defer fake.deleteVolumesMutex.Unlock()
	fake.DeleteVolumesStub = nil
	fake.deleteVolumesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) DeleteVolumesReturnsOnCall(i int, result1 error) {
	fake.deleteVolumesMutex.Lock()
	defer fake.deleteVolumesMutex.Unlock()
	fake.DeleteVolumesStub = nil
	if fake.deleteVolumesReturnsOnCall == nil {
		fake.deleteVolumesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVolumesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) EnsureFileExists(arg1 string, arg2 string, arg3 []byte) ([]byte, bool, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.ensureFileExistsMutex.Lock()
	ret, specificReturn := fake.ensureFileExistsReturnsOnCall[len(fake.ensureFileExistsArgsForCall)]
	fake.ensureFileExistsArgsForCall = append(fake.ensureFileExistsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("EnsureFileExists", []interface{}{arg1, arg2, arg3Copy})
	fake.ensureFileExistsMutex.Unlock()
	if fake.EnsureFileExistsStub != nil {
		return fake.EnsureFileExistsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.ensureFileExistsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeProvider) EnsureFileExistsCallCount() int {
	fake.ensureFileExistsMutex.RLock()
	defer fake.ensureFileExistsMutex.RUnlock()
	return len(fake.ensureFileExistsArgsForCall)
}

func (fake *FakeProvider) EnsureFileExistsCalls(stub func(string, string, []byte) ([]byte, bool, error)) {
	fake.ensureFileExistsMutex.Lock()
	defer fake.ensureFileExistsMutex.Unlock()
	fake.EnsureFileExistsStub = stub
}

func (fake *FakeProvider) EnsureFileExistsArgsForCall(i int) (string, string, []byte) {
	fake.ensureFileExistsMutex.RLock()
	defer fake.ensureFileExistsMutex.RUnlock()
	argsForCall := fake.ensureFileExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeProvider) EnsureFileExistsReturns(result1 []byte, result2 bool, result3 error) {
	fake.ensureFileExistsMutex.Lock()
	defer fake.ensureFileExistsMutex.Unlock()
	fake.EnsureFileExistsStub = nil
	fake.ensureFileExistsReturns = struct {
		result1 []byte
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeProvider) EnsureFileExistsReturnsOnCall(i int, result1 []byte, result2 bool, result3 error) {
	fake.ensureFileExistsMutex.Lock()
	defer fake.ensureFileExistsMutex.Unlock()
	fake.EnsureFileExistsStub = nil
	if fake.ensureFileExistsReturnsOnCall == nil {
		fake.ensureFileExistsReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 bool
			result3 error
		})
	}
	fake.ensureFileExistsReturnsOnCall[i] = struct {
		result1 []byte
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeProvider) FindLongestMatchingHostedZone(arg1 string) (string, string, error) {
	fake.findLongestMatchingHostedZoneMutex.Lock()
	ret, specificReturn := fake.findLongestMatchingHostedZoneReturnsOnCall[len(fake.findLongestMatchingHostedZoneArgsForCall)]
	fake.findLongestMatchingHostedZoneArgsForCall = append(fake.findLongestMatchingHostedZoneArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindLongestMatchingHostedZone", []interface{}{arg1})
	fake.findLongestMatchingHostedZoneMutex.Unlock()
	if fake.FindLongestMatchingHostedZoneStub != nil {
		return fake.FindLongestMatchingHostedZoneStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findLongestMatchingHostedZoneReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeProvider) FindLongestMatchingHostedZoneCallCount() int {
	fake.findLongestMatchingHostedZoneMutex.RLock()
	defer fake.findLongestMatchingHostedZoneMutex.RUnlock()
	return len(fake.findLongestMatchingHostedZoneArgsForCall)
}

func (fake *FakeProvider) FindLongestMatchingHostedZoneCalls(stub func(string) (string, string, error)) {
	fake.findLongestMatchingHostedZoneMutex.Lock()
	defer fake.findLongestMatchingHostedZoneMutex.Unlock()
	fake.FindLongestMatchingHostedZoneStub = stub
}

func (fake *FakeProvider) FindLongestMatchingHostedZoneArgsForCall(i int) string {
	fake.findLongestMatchingHostedZoneMutex.RLock()
	defer fake.findLongestMatchingHostedZoneMutex.RUnlock()
	argsForCall := fake.findLongestMatchingHostedZoneArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProvider) FindLongestMatchingHostedZoneReturns(result1 string, result2 string, result3 error) {
	fake.findLongestMatchingHostedZoneMutex.Lock()
	defer fake.findLongestMatchingHostedZoneMutex.Unlock()
	fake.FindLongestMatchingHostedZoneStub = nil
	fake.findLongestMatchingHostedZoneReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeProvider) FindLongestMatchingHostedZoneReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.findLongestMatchingHostedZoneMutex.Lock()
	defer fake.findLongestMatchingHostedZoneMutex.Unlock()
	fake.FindLongestMatchingHostedZoneStub = nil
	if fake.findLongestMatchingHostedZoneReturnsOnCall == nil {
		fake.findLongestMatchingHostedZoneReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.findLongestMatchingHostedZoneReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeProvider) HasFile(arg1 string, arg2 string) (bool, error) {
	fake.hasFileMutex.Lock()
	ret, specificReturn := fake.hasFileReturnsOnCall[len(fake.hasFileArgsForCall)]
	fake.hasFileArgsForCall = append(fake.hasFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("HasFile", []interface{}{arg1, arg2})
	fake.hasFileMutex.Unlock()
	if fake.HasFileStub != nil {
		return fake.HasFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.hasFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeProvider) HasFileCallCount() int {
	fake.hasFileMutex.RLock()
	defer fake.hasFileMutex.RUnlock()
	return len(fake.hasFileArgsForCall)
}

func (fake *FakeProvider) HasFileCalls(stub func(string, string) (bool, error)) {
	fake.hasFileMutex.Lock()
	defer fake.hasFileMutex.Unlock()
	fake.HasFileStub = stub
}

func (fake *FakeProvider) HasFileArgsForCall(i int) (string, string) {
	fake.hasFileMutex.RLock()
	defer fake.hasFileMutex.RUnlock()
	argsForCall := fake.hasFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeProvider) HasFileReturns(result1 bool, result2 error) {
	fake.hasFileMutex.Lock()
	defer fake.hasFileMutex.Unlock()
	fake.HasFileStub = nil
	fake.hasFileReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) HasFileReturnsOnCall(i int, result1 bool, result2 error) {
	fake.hasFileMutex.Lock()
	defer fake.hasFileMutex.Unlock()
	fake.HasFileStub = nil
	if fake.hasFileReturnsOnCall == nil {
		fake.hasFileReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasFileReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) IAAS() iaas.Name {
	fake.iAASMutex.Lock()
	ret, specificReturn := fake.iAASReturnsOnCall[len(fake.iAASArgsForCall)]
	fake.iAASArgsForCall = append(fake.iAASArgsForCall, struct {
	}{})
	fake.recordInvocation("IAAS", []interface{}{})
	fake.iAASMutex.Unlock()
	if fake.IAASStub != nil {
		return fake.IAASStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iAASReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) IAASCallCount() int {
	fake.iAASMutex.RLock()
	defer fake.iAASMutex.RUnlock()
	return len(fake.iAASArgsForCall)
}

func (fake *FakeProvider) IAASCalls(stub func() iaas.Name) {
	fake.iAASMutex.Lock()
	defer fake.iAASMutex.Unlock()
	fake.IAASStub = stub
}

func (fake *FakeProvider) IAASReturns(result1 iaas.Name) {
	fake.iAASMutex.Lock()
	defer fake.iAASMutex.Unlock()
	fake.IAASStub = nil
	fake.iAASReturns = struct {
		result1 iaas.Name
	}{result1}
}

func (fake *FakeProvider) IAASReturnsOnCall(i int, result1 iaas.Name) {
	fake.iAASMutex.Lock()
	defer fake.iAASMutex.Unlock()
	fake.IAASStub = nil
	if fake.iAASReturnsOnCall == nil {
		fake.iAASReturnsOnCall = make(map[int]struct {
			result1 iaas.Name
		})
	}
	fake.iAASReturnsOnCall[i] = struct {
		result1 iaas.Name
	}{result1}
}

func (fake *FakeProvider) LoadFile(arg1 string, arg2 string) ([]byte, error) {
	fake.loadFileMutex.Lock()
	ret, specificReturn := fake.loadFileReturnsOnCall[len(fake.loadFileArgsForCall)]
	fake.loadFileArgsForCall = append(fake.loadFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("LoadFile", []interface{}{arg1, arg2})
	fake.loadFileMutex.Unlock()
	if fake.LoadFileStub != nil {
		return fake.LoadFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.loadFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeProvider) LoadFileCallCount() int {
	fake.loadFileMutex.RLock()
	defer fake.loadFileMutex.RUnlock()
	return len(fake.loadFileArgsForCall)
}

func (fake *FakeProvider) LoadFileCalls(stub func(string, string) ([]byte, error)) {
	fake.loadFileMutex.Lock()
	defer fake.loadFileMutex.Unlock()
	fake.LoadFileStub = stub
}

func (fake *FakeProvider) LoadFileArgsForCall(i int) (string, string) {
	fake.loadFileMutex.RLock()
	defer fake.loadFileMutex.RUnlock()
	argsForCall := fake.loadFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeProvider) LoadFileReturns(result1 []byte, result2 error) {
	fake.loadFileMutex.Lock()
	defer fake.loadFileMutex.Unlock()
	fake.LoadFileStub = nil
	fake.loadFileReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) LoadFileReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.loadFileMutex.Lock()
	defer fake.loadFileMutex.Unlock()
	fake.LoadFileStub = nil
	if fake.loadFileReturnsOnCall == nil {
		fake.loadFileReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.loadFileReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) Region() string {
	fake.regionMutex.Lock()
	ret, specificReturn := fake.regionReturnsOnCall[len(fake.regionArgsForCall)]
	fake.regionArgsForCall = append(fake.regionArgsForCall, struct {
	}{})
	fake.recordInvocation("Region", []interface{}{})
	fake.regionMutex.Unlock()
	if fake.RegionStub != nil {
		return fake.RegionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.regionReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) RegionCallCount() int {
	fake.regionMutex.RLock()
	defer fake.regionMutex.RUnlock()
	return len(fake.regionArgsForCall)
}

func (fake *FakeProvider) RegionCalls(stub func() string) {
	fake.regionMutex.Lock()
	defer fake.regionMutex.Unlock()
	fake.RegionStub = stub
}

func (fake *FakeProvider) RegionReturns(result1 string) {
	fake.regionMutex.Lock()
	defer fake.regionMutex.Unlock()
	fake.RegionStub = nil
	fake.regionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeProvider) RegionReturnsOnCall(i int, result1 string) {
	fake.regionMutex.Lock()
	defer fake.regionMutex.Unlock()
	fake.RegionStub = nil
	if fake.regionReturnsOnCall == nil {
		fake.regionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.regionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeProvider) WorkerType(arg1 string) {
	fake.workerTypeMutex.Lock()
	fake.workerTypeArgsForCall = append(fake.workerTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WorkerType", []interface{}{arg1})
	fake.workerTypeMutex.Unlock()
	if fake.WorkerTypeStub != nil {
		fake.WorkerTypeStub(arg1)
	}
}

func (fake *FakeProvider) WorkerTypeCallCount() int {
	fake.workerTypeMutex.RLock()
	defer fake.workerTypeMutex.RUnlock()
	return len(fake.workerTypeArgsForCall)
}

func (fake *FakeProvider) WorkerTypeCalls(stub func(string)) {
	fake.workerTypeMutex.Lock()
	defer fake.workerTypeMutex.Unlock()
	fake.WorkerTypeStub = stub
}

func (fake *FakeProvider) WorkerTypeArgsForCall(i int) string {
	fake.workerTypeMutex.RLock()
	defer fake.workerTypeMutex.RUnlock()
	argsForCall := fake.workerTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProvider) WriteFile(arg1 string, arg2 string, arg3 []byte) error {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.writeFileMutex.Lock()
	ret, specificReturn := fake.writeFileReturnsOnCall[len(fake.writeFileArgsForCall)]
	fake.writeFileArgsForCall = append(fake.writeFileArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("WriteFile", []interface{}{arg1, arg2, arg3Copy})
	fake.writeFileMutex.Unlock()
	if fake.WriteFileStub != nil {
		return fake.WriteFileStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.writeFileReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) WriteFileCallCount() int {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	return len(fake.writeFileArgsForCall)
}

func (fake *FakeProvider) WriteFileCalls(stub func(string, string, []byte) error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = stub
}

func (fake *FakeProvider) WriteFileArgsForCall(i int) (string, string, []byte) {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	argsForCall := fake.writeFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeProvider) WriteFileReturns(result1 error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = nil
	fake.writeFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) WriteFileReturnsOnCall(i int, result1 error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = nil
	if fake.writeFileReturnsOnCall == nil {
		fake.writeFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeProvider) Zone(arg1 string) string {
	fake.zoneMutex.Lock()
	ret, specificReturn := fake.zoneReturnsOnCall[len(fake.zoneArgsForCall)]
	fake.zoneArgsForCall = append(fake.zoneArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Zone", []interface{}{arg1})
	fake.zoneMutex.Unlock()
	if fake.ZoneStub != nil {
		return fake.ZoneStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.zoneReturns
	return fakeReturns.result1
}

func (fake *FakeProvider) ZoneCallCount() int {
	fake.zoneMutex.RLock()
	defer fake.zoneMutex.RUnlock()
	return len(fake.zoneArgsForCall)
}

func (fake *FakeProvider) ZoneCalls(stub func(string) string) {
	fake.zoneMutex.Lock()
	defer fake.zoneMutex.Unlock()
	fake.ZoneStub = stub
}

func (fake *FakeProvider) ZoneArgsForCall(i int) string {
	fake.zoneMutex.RLock()
	defer fake.zoneMutex.RUnlock()
	argsForCall := fake.zoneArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProvider) ZoneReturns(result1 string) {
	fake.zoneMutex.Lock()
	defer fake.zoneMutex.Unlock()
	fake.ZoneStub = nil
	fake.zoneReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeProvider) ZoneReturnsOnCall(i int, result1 string) {
	fake.zoneMutex.Lock()
	defer fake.zoneMutex.Unlock()
	fake.ZoneStub = nil
	if fake.zoneReturnsOnCall == nil {
		fake.zoneReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.zoneReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeProvider) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attrMutex.RLock()
	defer fake.attrMutex.RUnlock()
	fake.bucketExistsMutex.RLock()
	defer fake.bucketExistsMutex.RUnlock()
	fake.checkForWhitelistedIPMutex.RLock()
	defer fake.checkForWhitelistedIPMutex.RUnlock()
	fake.chooseMutex.RLock()
	defer fake.chooseMutex.RUnlock()
	fake.createBucketMutex.RLock()
	defer fake.createBucketMutex.RUnlock()
	fake.createDatabasesMutex.RLock()
	defer fake.createDatabasesMutex.RUnlock()
	fake.dBTypeMutex.RLock()
	defer fake.dBTypeMutex.RUnlock()
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	fake.deleteVMsInDeploymentMutex.RLock()
	defer fake.deleteVMsInDeploymentMutex.RUnlock()
	fake.deleteVMsInVPCMutex.RLock()
	defer fake.deleteVMsInVPCMutex.RUnlock()
	fake.deleteVersionedBucketMutex.RLock()
	defer fake.deleteVersionedBucketMutex.RUnlock()
	fake.deleteVolumesMutex.RLock()
	defer fake.deleteVolumesMutex.RUnlock()
	fake.ensureFileExistsMutex.RLock()
	defer fake.ensureFileExistsMutex.RUnlock()
	fake.findLongestMatchingHostedZoneMutex.RLock()
	defer fake.findLongestMatchingHostedZoneMutex.RUnlock()
	fake.hasFileMutex.RLock()
	defer fake.hasFileMutex.RUnlock()
	fake.iAASMutex.RLock()
	defer fake.iAASMutex.RUnlock()
	fake.loadFileMutex.RLock()
	defer fake.loadFileMutex.RUnlock()
	fake.regionMutex.RLock()
	defer fake.regionMutex.RUnlock()
	fake.workerTypeMutex.RLock()
	defer fake.workerTypeMutex.RUnlock()
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	fake.zoneMutex.RLock()
	defer fake.zoneMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeProvider) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ iaas.Provider = new(FakeProvider)
