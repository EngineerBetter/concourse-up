// Code generated by counterfeiter. DO NOT EDIT.
package boshenvfakes

import (
	"sync"

	"github.com/EngineerBetter/concourse-up/bosh/internal/boshenv"
)

type FakeIBOSHCLI struct {
	CreateEnvStub        func(boshenv.Store, boshenv.IAASEnvironment, string, string, string, string, map[string]string) error
	createEnvMutex       sync.RWMutex
	createEnvArgsForCall []struct {
		arg1 boshenv.Store
		arg2 boshenv.IAASEnvironment
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 map[string]string
	}
	createEnvReturns struct {
		result1 error
	}
	createEnvReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteEnvStub        func(boshenv.Store, boshenv.IAASEnvironment, string, string, string, string, map[string]string) error
	deleteEnvMutex       sync.RWMutex
	deleteEnvArgsForCall []struct {
		arg1 boshenv.Store
		arg2 boshenv.IAASEnvironment
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 map[string]string
	}
	deleteEnvReturns struct {
		result1 error
	}
	deleteEnvReturnsOnCall map[int]struct {
		result1 error
	}
	LocksStub        func(boshenv.IAASEnvironment, string, string, string) ([]byte, error)
	locksMutex       sync.RWMutex
	locksArgsForCall []struct {
		arg1 boshenv.IAASEnvironment
		arg2 string
		arg3 string
		arg4 string
	}
	locksReturns struct {
		result1 []byte
		result2 error
	}
	locksReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	RecreateStub        func(boshenv.IAASEnvironment, string, string, string) error
	recreateMutex       sync.RWMutex
	recreateArgsForCall []struct {
		arg1 boshenv.IAASEnvironment
		arg2 string
		arg3 string
		arg4 string
	}
	recreateReturns struct {
		result1 error
	}
	recreateReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateCloudConfigStub        func(boshenv.IAASEnvironment, string, string, string) error
	updateCloudConfigMutex       sync.RWMutex
	updateCloudConfigArgsForCall []struct {
		arg1 boshenv.IAASEnvironment
		arg2 string
		arg3 string
		arg4 string
	}
	updateCloudConfigReturns struct {
		result1 error
	}
	updateCloudConfigReturnsOnCall map[int]struct {
		result1 error
	}
	UploadConcourseStemcellStub        func(boshenv.IAASEnvironment, string, string, string) error
	uploadConcourseStemcellMutex       sync.RWMutex
	uploadConcourseStemcellArgsForCall []struct {
		arg1 boshenv.IAASEnvironment
		arg2 string
		arg3 string
		arg4 string
	}
	uploadConcourseStemcellReturns struct {
		result1 error
	}
	uploadConcourseStemcellReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIBOSHCLI) CreateEnv(arg1 boshenv.Store, arg2 boshenv.IAASEnvironment, arg3 string, arg4 string, arg5 string, arg6 string, arg7 map[string]string) error {
	fake.createEnvMutex.Lock()
	ret, specificReturn := fake.createEnvReturnsOnCall[len(fake.createEnvArgsForCall)]
	fake.createEnvArgsForCall = append(fake.createEnvArgsForCall, struct {
		arg1 boshenv.Store
		arg2 boshenv.IAASEnvironment
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 map[string]string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.recordInvocation("CreateEnv", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.createEnvMutex.Unlock()
	if fake.CreateEnvStub != nil {
		return fake.CreateEnvStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createEnvReturns
	return fakeReturns.result1
}

func (fake *FakeIBOSHCLI) CreateEnvCallCount() int {
	fake.createEnvMutex.RLock()
	defer fake.createEnvMutex.RUnlock()
	return len(fake.createEnvArgsForCall)
}

func (fake *FakeIBOSHCLI) CreateEnvCalls(stub func(boshenv.Store, boshenv.IAASEnvironment, string, string, string, string, map[string]string) error) {
	fake.createEnvMutex.Lock()
	defer fake.createEnvMutex.Unlock()
	fake.CreateEnvStub = stub
}

func (fake *FakeIBOSHCLI) CreateEnvArgsForCall(i int) (boshenv.Store, boshenv.IAASEnvironment, string, string, string, string, map[string]string) {
	fake.createEnvMutex.RLock()
	defer fake.createEnvMutex.RUnlock()
	argsForCall := fake.createEnvArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeIBOSHCLI) CreateEnvReturns(result1 error) {
	fake.createEnvMutex.Lock()
	defer fake.createEnvMutex.Unlock()
	fake.CreateEnvStub = nil
	fake.createEnvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIBOSHCLI) CreateEnvReturnsOnCall(i int, result1 error) {
	fake.createEnvMutex.Lock()
	defer fake.createEnvMutex.Unlock()
	fake.CreateEnvStub = nil
	if fake.createEnvReturnsOnCall == nil {
		fake.createEnvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createEnvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIBOSHCLI) DeleteEnv(arg1 boshenv.Store, arg2 boshenv.IAASEnvironment, arg3 string, arg4 string, arg5 string, arg6 string, arg7 map[string]string) error {
	fake.deleteEnvMutex.Lock()
	ret, specificReturn := fake.deleteEnvReturnsOnCall[len(fake.deleteEnvArgsForCall)]
	fake.deleteEnvArgsForCall = append(fake.deleteEnvArgsForCall, struct {
		arg1 boshenv.Store
		arg2 boshenv.IAASEnvironment
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 map[string]string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.recordInvocation("DeleteEnv", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.deleteEnvMutex.Unlock()
	if fake.DeleteEnvStub != nil {
		return fake.DeleteEnvStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteEnvReturns
	return fakeReturns.result1
}

func (fake *FakeIBOSHCLI) DeleteEnvCallCount() int {
	fake.deleteEnvMutex.RLock()
	defer fake.deleteEnvMutex.RUnlock()
	return len(fake.deleteEnvArgsForCall)
}

func (fake *FakeIBOSHCLI) DeleteEnvCalls(stub func(boshenv.Store, boshenv.IAASEnvironment, string, string, string, string, map[string]string) error) {
	fake.deleteEnvMutex.Lock()
	defer fake.deleteEnvMutex.Unlock()
	fake.DeleteEnvStub = stub
}

func (fake *FakeIBOSHCLI) DeleteEnvArgsForCall(i int) (boshenv.Store, boshenv.IAASEnvironment, string, string, string, string, map[string]string) {
	fake.deleteEnvMutex.RLock()
	defer fake.deleteEnvMutex.RUnlock()
	argsForCall := fake.deleteEnvArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeIBOSHCLI) DeleteEnvReturns(result1 error) {
	fake.deleteEnvMutex.Lock()
	defer fake.deleteEnvMutex.Unlock()
	fake.DeleteEnvStub = nil
	fake.deleteEnvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIBOSHCLI) DeleteEnvReturnsOnCall(i int, result1 error) {
	fake.deleteEnvMutex.Lock()
	defer fake.deleteEnvMutex.Unlock()
	fake.DeleteEnvStub = nil
	if fake.deleteEnvReturnsOnCall == nil {
		fake.deleteEnvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteEnvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIBOSHCLI) Locks(arg1 boshenv.IAASEnvironment, arg2 string, arg3 string, arg4 string) ([]byte, error) {
	fake.locksMutex.Lock()
	ret, specificReturn := fake.locksReturnsOnCall[len(fake.locksArgsForCall)]
	fake.locksArgsForCall = append(fake.locksArgsForCall, struct {
		arg1 boshenv.IAASEnvironment
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Locks", []interface{}{arg1, arg2, arg3, arg4})
	fake.locksMutex.Unlock()
	if fake.LocksStub != nil {
		return fake.LocksStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.locksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIBOSHCLI) LocksCallCount() int {
	fake.locksMutex.RLock()
	defer fake.locksMutex.RUnlock()
	return len(fake.locksArgsForCall)
}

func (fake *FakeIBOSHCLI) LocksCalls(stub func(boshenv.IAASEnvironment, string, string, string) ([]byte, error)) {
	fake.locksMutex.Lock()
	defer fake.locksMutex.Unlock()
	fake.LocksStub = stub
}

func (fake *FakeIBOSHCLI) LocksArgsForCall(i int) (boshenv.IAASEnvironment, string, string, string) {
	fake.locksMutex.RLock()
	defer fake.locksMutex.RUnlock()
	argsForCall := fake.locksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIBOSHCLI) LocksReturns(result1 []byte, result2 error) {
	fake.locksMutex.Lock()
	defer fake.locksMutex.Unlock()
	fake.LocksStub = nil
	fake.locksReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIBOSHCLI) LocksReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.locksMutex.Lock()
	defer fake.locksMutex.Unlock()
	fake.LocksStub = nil
	if fake.locksReturnsOnCall == nil {
		fake.locksReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.locksReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIBOSHCLI) Recreate(arg1 boshenv.IAASEnvironment, arg2 string, arg3 string, arg4 string) error {
	fake.recreateMutex.Lock()
	ret, specificReturn := fake.recreateReturnsOnCall[len(fake.recreateArgsForCall)]
	fake.recreateArgsForCall = append(fake.recreateArgsForCall, struct {
		arg1 boshenv.IAASEnvironment
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Recreate", []interface{}{arg1, arg2, arg3, arg4})
	fake.recreateMutex.Unlock()
	if fake.RecreateStub != nil {
		return fake.RecreateStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.recreateReturns
	return fakeReturns.result1
}

func (fake *FakeIBOSHCLI) RecreateCallCount() int {
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	return len(fake.recreateArgsForCall)
}

func (fake *FakeIBOSHCLI) RecreateCalls(stub func(boshenv.IAASEnvironment, string, string, string) error) {
	fake.recreateMutex.Lock()
	defer fake.recreateMutex.Unlock()
	fake.RecreateStub = stub
}

func (fake *FakeIBOSHCLI) RecreateArgsForCall(i int) (boshenv.IAASEnvironment, string, string, string) {
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	argsForCall := fake.recreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIBOSHCLI) RecreateReturns(result1 error) {
	fake.recreateMutex.Lock()
	defer fake.recreateMutex.Unlock()
	fake.RecreateStub = nil
	fake.recreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIBOSHCLI) RecreateReturnsOnCall(i int, result1 error) {
	fake.recreateMutex.Lock()
	defer fake.recreateMutex.Unlock()
	fake.RecreateStub = nil
	if fake.recreateReturnsOnCall == nil {
		fake.recreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.recreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIBOSHCLI) UpdateCloudConfig(arg1 boshenv.IAASEnvironment, arg2 string, arg3 string, arg4 string) error {
	fake.updateCloudConfigMutex.Lock()
	ret, specificReturn := fake.updateCloudConfigReturnsOnCall[len(fake.updateCloudConfigArgsForCall)]
	fake.updateCloudConfigArgsForCall = append(fake.updateCloudConfigArgsForCall, struct {
		arg1 boshenv.IAASEnvironment
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("UpdateCloudConfig", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateCloudConfigMutex.Unlock()
	if fake.UpdateCloudConfigStub != nil {
		return fake.UpdateCloudConfigStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateCloudConfigReturns
	return fakeReturns.result1
}

func (fake *FakeIBOSHCLI) UpdateCloudConfigCallCount() int {
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	return len(fake.updateCloudConfigArgsForCall)
}

func (fake *FakeIBOSHCLI) UpdateCloudConfigCalls(stub func(boshenv.IAASEnvironment, string, string, string) error) {
	fake.updateCloudConfigMutex.Lock()
	defer fake.updateCloudConfigMutex.Unlock()
	fake.UpdateCloudConfigStub = stub
}

func (fake *FakeIBOSHCLI) UpdateCloudConfigArgsForCall(i int) (boshenv.IAASEnvironment, string, string, string) {
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	argsForCall := fake.updateCloudConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIBOSHCLI) UpdateCloudConfigReturns(result1 error) {
	fake.updateCloudConfigMutex.Lock()
	defer fake.updateCloudConfigMutex.Unlock()
	fake.UpdateCloudConfigStub = nil
	fake.updateCloudConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIBOSHCLI) UpdateCloudConfigReturnsOnCall(i int, result1 error) {
	fake.updateCloudConfigMutex.Lock()
	defer fake.updateCloudConfigMutex.Unlock()
	fake.UpdateCloudConfigStub = nil
	if fake.updateCloudConfigReturnsOnCall == nil {
		fake.updateCloudConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCloudConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIBOSHCLI) UploadConcourseStemcell(arg1 boshenv.IAASEnvironment, arg2 string, arg3 string, arg4 string) error {
	fake.uploadConcourseStemcellMutex.Lock()
	ret, specificReturn := fake.uploadConcourseStemcellReturnsOnCall[len(fake.uploadConcourseStemcellArgsForCall)]
	fake.uploadConcourseStemcellArgsForCall = append(fake.uploadConcourseStemcellArgsForCall, struct {
		arg1 boshenv.IAASEnvironment
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("UploadConcourseStemcell", []interface{}{arg1, arg2, arg3, arg4})
	fake.uploadConcourseStemcellMutex.Unlock()
	if fake.UploadConcourseStemcellStub != nil {
		return fake.UploadConcourseStemcellStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uploadConcourseStemcellReturns
	return fakeReturns.result1
}

func (fake *FakeIBOSHCLI) UploadConcourseStemcellCallCount() int {
	fake.uploadConcourseStemcellMutex.RLock()
	defer fake.uploadConcourseStemcellMutex.RUnlock()
	return len(fake.uploadConcourseStemcellArgsForCall)
}

func (fake *FakeIBOSHCLI) UploadConcourseStemcellCalls(stub func(boshenv.IAASEnvironment, string, string, string) error) {
	fake.uploadConcourseStemcellMutex.Lock()
	defer fake.uploadConcourseStemcellMutex.Unlock()
	fake.UploadConcourseStemcellStub = stub
}

func (fake *FakeIBOSHCLI) UploadConcourseStemcellArgsForCall(i int) (boshenv.IAASEnvironment, string, string, string) {
	fake.uploadConcourseStemcellMutex.RLock()
	defer fake.uploadConcourseStemcellMutex.RUnlock()
	argsForCall := fake.uploadConcourseStemcellArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIBOSHCLI) UploadConcourseStemcellReturns(result1 error) {
	fake.uploadConcourseStemcellMutex.Lock()
	defer fake.uploadConcourseStemcellMutex.Unlock()
	fake.UploadConcourseStemcellStub = nil
	fake.uploadConcourseStemcellReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIBOSHCLI) UploadConcourseStemcellReturnsOnCall(i int, result1 error) {
	fake.uploadConcourseStemcellMutex.Lock()
	defer fake.uploadConcourseStemcellMutex.Unlock()
	fake.UploadConcourseStemcellStub = nil
	if fake.uploadConcourseStemcellReturnsOnCall == nil {
		fake.uploadConcourseStemcellReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadConcourseStemcellReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIBOSHCLI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createEnvMutex.RLock()
	defer fake.createEnvMutex.RUnlock()
	fake.deleteEnvMutex.RLock()
	defer fake.deleteEnvMutex.RUnlock()
	fake.locksMutex.RLock()
	defer fake.locksMutex.RUnlock()
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	fake.uploadConcourseStemcellMutex.RLock()
	defer fake.uploadConcourseStemcellMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIBOSHCLI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ boshenv.IBOSHCLI = new(FakeIBOSHCLI)
