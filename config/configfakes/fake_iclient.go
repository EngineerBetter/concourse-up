// Code generated by counterfeiter. DO NOT EDIT.
package configfakes

import (
	"sync"

	"github.com/EngineerBetter/concourse-up/config"
)

type FakeIClient struct {
	ConfigExistsStub        func() (bool, error)
	configExistsMutex       sync.RWMutex
	configExistsArgsForCall []struct {
	}
	configExistsReturns struct {
		result1 bool
		result2 error
	}
	configExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeleteAllStub        func(config.Config) error
	deleteAllMutex       sync.RWMutex
	deleteAllArgsForCall []struct {
		arg1 config.Config
	}
	deleteAllReturns struct {
		result1 error
	}
	deleteAllReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteAssetStub        func(string) error
	deleteAssetMutex       sync.RWMutex
	deleteAssetArgsForCall []struct {
		arg1 string
	}
	deleteAssetReturns struct {
		result1 error
	}
	deleteAssetReturnsOnCall map[int]struct {
		result1 error
	}
	HasAssetStub        func(string) (bool, error)
	hasAssetMutex       sync.RWMutex
	hasAssetArgsForCall []struct {
		arg1 string
	}
	hasAssetReturns struct {
		result1 bool
		result2 error
	}
	hasAssetReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	LoadStub        func() (config.Config, error)
	loadMutex       sync.RWMutex
	loadArgsForCall []struct {
	}
	loadReturns struct {
		result1 config.Config
		result2 error
	}
	loadReturnsOnCall map[int]struct {
		result1 config.Config
		result2 error
	}
	LoadAssetStub        func(string) ([]byte, error)
	loadAssetMutex       sync.RWMutex
	loadAssetArgsForCall []struct {
		arg1 string
	}
	loadAssetReturns struct {
		result1 []byte
		result2 error
	}
	loadAssetReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	NewConfigStub        func() config.Config
	newConfigMutex       sync.RWMutex
	newConfigArgsForCall []struct {
	}
	newConfigReturns struct {
		result1 config.Config
	}
	newConfigReturnsOnCall map[int]struct {
		result1 config.Config
	}
	StoreAssetStub        func(string, []byte) error
	storeAssetMutex       sync.RWMutex
	storeAssetArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	storeAssetReturns struct {
		result1 error
	}
	storeAssetReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateStub        func(config.Config) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 config.Config
	}
	updateReturns struct {
		result1 error
	}
	updateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIClient) ConfigExists() (bool, error) {
	fake.configExistsMutex.Lock()
	ret, specificReturn := fake.configExistsReturnsOnCall[len(fake.configExistsArgsForCall)]
	fake.configExistsArgsForCall = append(fake.configExistsArgsForCall, struct {
	}{})
	fake.recordInvocation("ConfigExists", []interface{}{})
	fake.configExistsMutex.Unlock()
	if fake.ConfigExistsStub != nil {
		return fake.ConfigExistsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.configExistsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIClient) ConfigExistsCallCount() int {
	fake.configExistsMutex.RLock()
	defer fake.configExistsMutex.RUnlock()
	return len(fake.configExistsArgsForCall)
}

func (fake *FakeIClient) ConfigExistsCalls(stub func() (bool, error)) {
	fake.configExistsMutex.Lock()
	defer fake.configExistsMutex.Unlock()
	fake.ConfigExistsStub = stub
}

func (fake *FakeIClient) ConfigExistsReturns(result1 bool, result2 error) {
	fake.configExistsMutex.Lock()
	defer fake.configExistsMutex.Unlock()
	fake.ConfigExistsStub = nil
	fake.configExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) ConfigExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.configExistsMutex.Lock()
	defer fake.configExistsMutex.Unlock()
	fake.ConfigExistsStub = nil
	if fake.configExistsReturnsOnCall == nil {
		fake.configExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.configExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) DeleteAll(arg1 config.Config) error {
	fake.deleteAllMutex.Lock()
	ret, specificReturn := fake.deleteAllReturnsOnCall[len(fake.deleteAllArgsForCall)]
	fake.deleteAllArgsForCall = append(fake.deleteAllArgsForCall, struct {
		arg1 config.Config
	}{arg1})
	fake.recordInvocation("DeleteAll", []interface{}{arg1})
	fake.deleteAllMutex.Unlock()
	if fake.DeleteAllStub != nil {
		return fake.DeleteAllStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteAllReturns
	return fakeReturns.result1
}

func (fake *FakeIClient) DeleteAllCallCount() int {
	fake.deleteAllMutex.RLock()
	defer fake.deleteAllMutex.RUnlock()
	return len(fake.deleteAllArgsForCall)
}

func (fake *FakeIClient) DeleteAllCalls(stub func(config.Config) error) {
	fake.deleteAllMutex.Lock()
	defer fake.deleteAllMutex.Unlock()
	fake.DeleteAllStub = stub
}

func (fake *FakeIClient) DeleteAllArgsForCall(i int) config.Config {
	fake.deleteAllMutex.RLock()
	defer fake.deleteAllMutex.RUnlock()
	argsForCall := fake.deleteAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIClient) DeleteAllReturns(result1 error) {
	fake.deleteAllMutex.Lock()
	defer fake.deleteAllMutex.Unlock()
	fake.DeleteAllStub = nil
	fake.deleteAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteAllReturnsOnCall(i int, result1 error) {
	fake.deleteAllMutex.Lock()
	defer fake.deleteAllMutex.Unlock()
	fake.DeleteAllStub = nil
	if fake.deleteAllReturnsOnCall == nil {
		fake.deleteAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteAsset(arg1 string) error {
	fake.deleteAssetMutex.Lock()
	ret, specificReturn := fake.deleteAssetReturnsOnCall[len(fake.deleteAssetArgsForCall)]
	fake.deleteAssetArgsForCall = append(fake.deleteAssetArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteAsset", []interface{}{arg1})
	fake.deleteAssetMutex.Unlock()
	if fake.DeleteAssetStub != nil {
		return fake.DeleteAssetStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteAssetReturns
	return fakeReturns.result1
}

func (fake *FakeIClient) DeleteAssetCallCount() int {
	fake.deleteAssetMutex.RLock()
	defer fake.deleteAssetMutex.RUnlock()
	return len(fake.deleteAssetArgsForCall)
}

func (fake *FakeIClient) DeleteAssetCalls(stub func(string) error) {
	fake.deleteAssetMutex.Lock()
	defer fake.deleteAssetMutex.Unlock()
	fake.DeleteAssetStub = stub
}

func (fake *FakeIClient) DeleteAssetArgsForCall(i int) string {
	fake.deleteAssetMutex.RLock()
	defer fake.deleteAssetMutex.RUnlock()
	argsForCall := fake.deleteAssetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIClient) DeleteAssetReturns(result1 error) {
	fake.deleteAssetMutex.Lock()
	defer fake.deleteAssetMutex.Unlock()
	fake.DeleteAssetStub = nil
	fake.deleteAssetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteAssetReturnsOnCall(i int, result1 error) {
	fake.deleteAssetMutex.Lock()
	defer fake.deleteAssetMutex.Unlock()
	fake.DeleteAssetStub = nil
	if fake.deleteAssetReturnsOnCall == nil {
		fake.deleteAssetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAssetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) HasAsset(arg1 string) (bool, error) {
	fake.hasAssetMutex.Lock()
	ret, specificReturn := fake.hasAssetReturnsOnCall[len(fake.hasAssetArgsForCall)]
	fake.hasAssetArgsForCall = append(fake.hasAssetArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("HasAsset", []interface{}{arg1})
	fake.hasAssetMutex.Unlock()
	if fake.HasAssetStub != nil {
		return fake.HasAssetStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.hasAssetReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIClient) HasAssetCallCount() int {
	fake.hasAssetMutex.RLock()
	defer fake.hasAssetMutex.RUnlock()
	return len(fake.hasAssetArgsForCall)
}

func (fake *FakeIClient) HasAssetCalls(stub func(string) (bool, error)) {
	fake.hasAssetMutex.Lock()
	defer fake.hasAssetMutex.Unlock()
	fake.HasAssetStub = stub
}

func (fake *FakeIClient) HasAssetArgsForCall(i int) string {
	fake.hasAssetMutex.RLock()
	defer fake.hasAssetMutex.RUnlock()
	argsForCall := fake.hasAssetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIClient) HasAssetReturns(result1 bool, result2 error) {
	fake.hasAssetMutex.Lock()
	defer fake.hasAssetMutex.Unlock()
	fake.HasAssetStub = nil
	fake.hasAssetReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) HasAssetReturnsOnCall(i int, result1 bool, result2 error) {
	fake.hasAssetMutex.Lock()
	defer fake.hasAssetMutex.Unlock()
	fake.HasAssetStub = nil
	if fake.hasAssetReturnsOnCall == nil {
		fake.hasAssetReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasAssetReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) Load() (config.Config, error) {
	fake.loadMutex.Lock()
	ret, specificReturn := fake.loadReturnsOnCall[len(fake.loadArgsForCall)]
	fake.loadArgsForCall = append(fake.loadArgsForCall, struct {
	}{})
	fake.recordInvocation("Load", []interface{}{})
	fake.loadMutex.Unlock()
	if fake.LoadStub != nil {
		return fake.LoadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.loadReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIClient) LoadCallCount() int {
	fake.loadMutex.RLock()
	defer fake.loadMutex.RUnlock()
	return len(fake.loadArgsForCall)
}

func (fake *FakeIClient) LoadCalls(stub func() (config.Config, error)) {
	fake.loadMutex.Lock()
	defer fake.loadMutex.Unlock()
	fake.LoadStub = stub
}

func (fake *FakeIClient) LoadReturns(result1 config.Config, result2 error) {
	fake.loadMutex.Lock()
	defer fake.loadMutex.Unlock()
	fake.LoadStub = nil
	fake.loadReturns = struct {
		result1 config.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) LoadReturnsOnCall(i int, result1 config.Config, result2 error) {
	fake.loadMutex.Lock()
	defer fake.loadMutex.Unlock()
	fake.LoadStub = nil
	if fake.loadReturnsOnCall == nil {
		fake.loadReturnsOnCall = make(map[int]struct {
			result1 config.Config
			result2 error
		})
	}
	fake.loadReturnsOnCall[i] = struct {
		result1 config.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) LoadAsset(arg1 string) ([]byte, error) {
	fake.loadAssetMutex.Lock()
	ret, specificReturn := fake.loadAssetReturnsOnCall[len(fake.loadAssetArgsForCall)]
	fake.loadAssetArgsForCall = append(fake.loadAssetArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("LoadAsset", []interface{}{arg1})
	fake.loadAssetMutex.Unlock()
	if fake.LoadAssetStub != nil {
		return fake.LoadAssetStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.loadAssetReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIClient) LoadAssetCallCount() int {
	fake.loadAssetMutex.RLock()
	defer fake.loadAssetMutex.RUnlock()
	return len(fake.loadAssetArgsForCall)
}

func (fake *FakeIClient) LoadAssetCalls(stub func(string) ([]byte, error)) {
	fake.loadAssetMutex.Lock()
	defer fake.loadAssetMutex.Unlock()
	fake.LoadAssetStub = stub
}

func (fake *FakeIClient) LoadAssetArgsForCall(i int) string {
	fake.loadAssetMutex.RLock()
	defer fake.loadAssetMutex.RUnlock()
	argsForCall := fake.loadAssetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIClient) LoadAssetReturns(result1 []byte, result2 error) {
	fake.loadAssetMutex.Lock()
	defer fake.loadAssetMutex.Unlock()
	fake.LoadAssetStub = nil
	fake.loadAssetReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) LoadAssetReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.loadAssetMutex.Lock()
	defer fake.loadAssetMutex.Unlock()
	fake.LoadAssetStub = nil
	if fake.loadAssetReturnsOnCall == nil {
		fake.loadAssetReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.loadAssetReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) NewConfig() config.Config {
	fake.newConfigMutex.Lock()
	ret, specificReturn := fake.newConfigReturnsOnCall[len(fake.newConfigArgsForCall)]
	fake.newConfigArgsForCall = append(fake.newConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("NewConfig", []interface{}{})
	fake.newConfigMutex.Unlock()
	if fake.NewConfigStub != nil {
		return fake.NewConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newConfigReturns
	return fakeReturns.result1
}

func (fake *FakeIClient) NewConfigCallCount() int {
	fake.newConfigMutex.RLock()
	defer fake.newConfigMutex.RUnlock()
	return len(fake.newConfigArgsForCall)
}

func (fake *FakeIClient) NewConfigCalls(stub func() config.Config) {
	fake.newConfigMutex.Lock()
	defer fake.newConfigMutex.Unlock()
	fake.NewConfigStub = stub
}

func (fake *FakeIClient) NewConfigReturns(result1 config.Config) {
	fake.newConfigMutex.Lock()
	defer fake.newConfigMutex.Unlock()
	fake.NewConfigStub = nil
	fake.newConfigReturns = struct {
		result1 config.Config
	}{result1}
}

func (fake *FakeIClient) NewConfigReturnsOnCall(i int, result1 config.Config) {
	fake.newConfigMutex.Lock()
	defer fake.newConfigMutex.Unlock()
	fake.NewConfigStub = nil
	if fake.newConfigReturnsOnCall == nil {
		fake.newConfigReturnsOnCall = make(map[int]struct {
			result1 config.Config
		})
	}
	fake.newConfigReturnsOnCall[i] = struct {
		result1 config.Config
	}{result1}
}

func (fake *FakeIClient) StoreAsset(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.storeAssetMutex.Lock()
	ret, specificReturn := fake.storeAssetReturnsOnCall[len(fake.storeAssetArgsForCall)]
	fake.storeAssetArgsForCall = append(fake.storeAssetArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	fake.recordInvocation("StoreAsset", []interface{}{arg1, arg2Copy})
	fake.storeAssetMutex.Unlock()
	if fake.StoreAssetStub != nil {
		return fake.StoreAssetStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.storeAssetReturns
	return fakeReturns.result1
}

func (fake *FakeIClient) StoreAssetCallCount() int {
	fake.storeAssetMutex.RLock()
	defer fake.storeAssetMutex.RUnlock()
	return len(fake.storeAssetArgsForCall)
}

func (fake *FakeIClient) StoreAssetCalls(stub func(string, []byte) error) {
	fake.storeAssetMutex.Lock()
	defer fake.storeAssetMutex.Unlock()
	fake.StoreAssetStub = stub
}

func (fake *FakeIClient) StoreAssetArgsForCall(i int) (string, []byte) {
	fake.storeAssetMutex.RLock()
	defer fake.storeAssetMutex.RUnlock()
	argsForCall := fake.storeAssetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIClient) StoreAssetReturns(result1 error) {
	fake.storeAssetMutex.Lock()
	defer fake.storeAssetMutex.Unlock()
	fake.StoreAssetStub = nil
	fake.storeAssetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) StoreAssetReturnsOnCall(i int, result1 error) {
	fake.storeAssetMutex.Lock()
	defer fake.storeAssetMutex.Unlock()
	fake.StoreAssetStub = nil
	if fake.storeAssetReturnsOnCall == nil {
		fake.storeAssetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeAssetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) Update(arg1 config.Config) error {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 config.Config
	}{arg1})
	fake.recordInvocation("Update", []interface{}{arg1})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateReturns
	return fakeReturns.result1
}

func (fake *FakeIClient) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeIClient) UpdateCalls(stub func(config.Config) error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeIClient) UpdateArgsForCall(i int) config.Config {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIClient) UpdateReturns(result1 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) UpdateReturnsOnCall(i int, result1 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.configExistsMutex.RLock()
	defer fake.configExistsMutex.RUnlock()
	fake.deleteAllMutex.RLock()
	defer fake.deleteAllMutex.RUnlock()
	fake.deleteAssetMutex.RLock()
	defer fake.deleteAssetMutex.RUnlock()
	fake.hasAssetMutex.RLock()
	defer fake.hasAssetMutex.RUnlock()
	fake.loadMutex.RLock()
	defer fake.loadMutex.RUnlock()
	fake.loadAssetMutex.RLock()
	defer fake.loadAssetMutex.RUnlock()
	fake.newConfigMutex.RLock()
	defer fake.newConfigMutex.RUnlock()
	fake.storeAssetMutex.RLock()
	defer fake.storeAssetMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ config.IClient = new(FakeIClient)
