// Code generated by counterfeiter. DO NOT EDIT.
package configfakes

import (
	"sync"

	"github.com/EngineerBetter/concourse-up/config"
)

type FakeIClient struct {
	LoadStub        func() (*config.Config, error)
	loadMutex       sync.RWMutex
	loadArgsForCall []struct{}
	loadReturns     struct {
		result1 *config.Config
		result2 error
	}
	loadReturnsOnCall map[int]struct {
		result1 *config.Config
		result2 error
	}
	DeleteAllStub        func(*config.Config) error
	deleteAllMutex       sync.RWMutex
	deleteAllArgsForCall []struct {
		arg1 *config.Config
	}
	deleteAllReturns struct {
		result1 error
	}
	deleteAllReturnsOnCall map[int]struct {
		result1 error
	}
	LoadOrCreateStub        func(deployArgs *config.DeployArgs) (*config.Config, bool, error)
	loadOrCreateMutex       sync.RWMutex
	loadOrCreateArgsForCall []struct {
		deployArgs *config.DeployArgs
	}
	loadOrCreateReturns struct {
		result1 *config.Config
		result2 bool
		result3 error
	}
	loadOrCreateReturnsOnCall map[int]struct {
		result1 *config.Config
		result2 bool
		result3 error
	}
	UpdateStub        func(*config.Config) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 *config.Config
	}
	updateReturns struct {
		result1 error
	}
	updateReturnsOnCall map[int]struct {
		result1 error
	}
	StoreAssetStub        func(filename string, contents []byte) error
	storeAssetMutex       sync.RWMutex
	storeAssetArgsForCall []struct {
		filename string
		contents []byte
	}
	storeAssetReturns struct {
		result1 error
	}
	storeAssetReturnsOnCall map[int]struct {
		result1 error
	}
	HasAssetStub        func(filename string) (bool, error)
	hasAssetMutex       sync.RWMutex
	hasAssetArgsForCall []struct {
		filename string
	}
	hasAssetReturns struct {
		result1 bool
		result2 error
	}
	hasAssetReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	LoadAssetStub        func(filename string) ([]byte, error)
	loadAssetMutex       sync.RWMutex
	loadAssetArgsForCall []struct {
		filename string
	}
	loadAssetReturns struct {
		result1 []byte
		result2 error
	}
	loadAssetReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	DeleteAssetStub        func(filename string) error
	deleteAssetMutex       sync.RWMutex
	deleteAssetArgsForCall []struct {
		filename string
	}
	deleteAssetReturns struct {
		result1 error
	}
	deleteAssetReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIClient) Load() (*config.Config, error) {
	fake.loadMutex.Lock()
	ret, specificReturn := fake.loadReturnsOnCall[len(fake.loadArgsForCall)]
	fake.loadArgsForCall = append(fake.loadArgsForCall, struct{}{})
	fake.recordInvocation("Load", []interface{}{})
	fake.loadMutex.Unlock()
	if fake.LoadStub != nil {
		return fake.LoadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.loadReturns.result1, fake.loadReturns.result2
}

func (fake *FakeIClient) LoadCallCount() int {
	fake.loadMutex.RLock()
	defer fake.loadMutex.RUnlock()
	return len(fake.loadArgsForCall)
}

func (fake *FakeIClient) LoadReturns(result1 *config.Config, result2 error) {
	fake.LoadStub = nil
	fake.loadReturns = struct {
		result1 *config.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) LoadReturnsOnCall(i int, result1 *config.Config, result2 error) {
	fake.LoadStub = nil
	if fake.loadReturnsOnCall == nil {
		fake.loadReturnsOnCall = make(map[int]struct {
			result1 *config.Config
			result2 error
		})
	}
	fake.loadReturnsOnCall[i] = struct {
		result1 *config.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) DeleteAll(arg1 *config.Config) error {
	fake.deleteAllMutex.Lock()
	ret, specificReturn := fake.deleteAllReturnsOnCall[len(fake.deleteAllArgsForCall)]
	fake.deleteAllArgsForCall = append(fake.deleteAllArgsForCall, struct {
		arg1 *config.Config
	}{arg1})
	fake.recordInvocation("DeleteAll", []interface{}{arg1})
	fake.deleteAllMutex.Unlock()
	if fake.DeleteAllStub != nil {
		return fake.DeleteAllStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteAllReturns.result1
}

func (fake *FakeIClient) DeleteAllCallCount() int {
	fake.deleteAllMutex.RLock()
	defer fake.deleteAllMutex.RUnlock()
	return len(fake.deleteAllArgsForCall)
}

func (fake *FakeIClient) DeleteAllArgsForCall(i int) *config.Config {
	fake.deleteAllMutex.RLock()
	defer fake.deleteAllMutex.RUnlock()
	return fake.deleteAllArgsForCall[i].arg1
}

func (fake *FakeIClient) DeleteAllReturns(result1 error) {
	fake.DeleteAllStub = nil
	fake.deleteAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteAllReturnsOnCall(i int, result1 error) {
	fake.DeleteAllStub = nil
	if fake.deleteAllReturnsOnCall == nil {
		fake.deleteAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) LoadOrCreate(deployArgs *config.DeployArgs) (*config.Config, bool, error) {
	fake.loadOrCreateMutex.Lock()
	ret, specificReturn := fake.loadOrCreateReturnsOnCall[len(fake.loadOrCreateArgsForCall)]
	fake.loadOrCreateArgsForCall = append(fake.loadOrCreateArgsForCall, struct {
		deployArgs *config.DeployArgs
	}{deployArgs})
	fake.recordInvocation("LoadOrCreate", []interface{}{deployArgs})
	fake.loadOrCreateMutex.Unlock()
	if fake.LoadOrCreateStub != nil {
		return fake.LoadOrCreateStub(deployArgs)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.loadOrCreateReturns.result1, fake.loadOrCreateReturns.result2, fake.loadOrCreateReturns.result3
}

func (fake *FakeIClient) LoadOrCreateCallCount() int {
	fake.loadOrCreateMutex.RLock()
	defer fake.loadOrCreateMutex.RUnlock()
	return len(fake.loadOrCreateArgsForCall)
}

func (fake *FakeIClient) LoadOrCreateArgsForCall(i int) *config.DeployArgs {
	fake.loadOrCreateMutex.RLock()
	defer fake.loadOrCreateMutex.RUnlock()
	return fake.loadOrCreateArgsForCall[i].deployArgs
}

func (fake *FakeIClient) LoadOrCreateReturns(result1 *config.Config, result2 bool, result3 error) {
	fake.LoadOrCreateStub = nil
	fake.loadOrCreateReturns = struct {
		result1 *config.Config
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIClient) LoadOrCreateReturnsOnCall(i int, result1 *config.Config, result2 bool, result3 error) {
	fake.LoadOrCreateStub = nil
	if fake.loadOrCreateReturnsOnCall == nil {
		fake.loadOrCreateReturnsOnCall = make(map[int]struct {
			result1 *config.Config
			result2 bool
			result3 error
		})
	}
	fake.loadOrCreateReturnsOnCall[i] = struct {
		result1 *config.Config
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIClient) Update(arg1 *config.Config) error {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 *config.Config
	}{arg1})
	fake.recordInvocation("Update", []interface{}{arg1})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateReturns.result1
}

func (fake *FakeIClient) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeIClient) UpdateArgsForCall(i int) *config.Config {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].arg1
}

func (fake *FakeIClient) UpdateReturns(result1 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) UpdateReturnsOnCall(i int, result1 error) {
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) StoreAsset(filename string, contents []byte) error {
	var contentsCopy []byte
	if contents != nil {
		contentsCopy = make([]byte, len(contents))
		copy(contentsCopy, contents)
	}
	fake.storeAssetMutex.Lock()
	ret, specificReturn := fake.storeAssetReturnsOnCall[len(fake.storeAssetArgsForCall)]
	fake.storeAssetArgsForCall = append(fake.storeAssetArgsForCall, struct {
		filename string
		contents []byte
	}{filename, contentsCopy})
	fake.recordInvocation("StoreAsset", []interface{}{filename, contentsCopy})
	fake.storeAssetMutex.Unlock()
	if fake.StoreAssetStub != nil {
		return fake.StoreAssetStub(filename, contents)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.storeAssetReturns.result1
}

func (fake *FakeIClient) StoreAssetCallCount() int {
	fake.storeAssetMutex.RLock()
	defer fake.storeAssetMutex.RUnlock()
	return len(fake.storeAssetArgsForCall)
}

func (fake *FakeIClient) StoreAssetArgsForCall(i int) (string, []byte) {
	fake.storeAssetMutex.RLock()
	defer fake.storeAssetMutex.RUnlock()
	return fake.storeAssetArgsForCall[i].filename, fake.storeAssetArgsForCall[i].contents
}

func (fake *FakeIClient) StoreAssetReturns(result1 error) {
	fake.StoreAssetStub = nil
	fake.storeAssetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) StoreAssetReturnsOnCall(i int, result1 error) {
	fake.StoreAssetStub = nil
	if fake.storeAssetReturnsOnCall == nil {
		fake.storeAssetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeAssetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) HasAsset(filename string) (bool, error) {
	fake.hasAssetMutex.Lock()
	ret, specificReturn := fake.hasAssetReturnsOnCall[len(fake.hasAssetArgsForCall)]
	fake.hasAssetArgsForCall = append(fake.hasAssetArgsForCall, struct {
		filename string
	}{filename})
	fake.recordInvocation("HasAsset", []interface{}{filename})
	fake.hasAssetMutex.Unlock()
	if fake.HasAssetStub != nil {
		return fake.HasAssetStub(filename)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hasAssetReturns.result1, fake.hasAssetReturns.result2
}

func (fake *FakeIClient) HasAssetCallCount() int {
	fake.hasAssetMutex.RLock()
	defer fake.hasAssetMutex.RUnlock()
	return len(fake.hasAssetArgsForCall)
}

func (fake *FakeIClient) HasAssetArgsForCall(i int) string {
	fake.hasAssetMutex.RLock()
	defer fake.hasAssetMutex.RUnlock()
	return fake.hasAssetArgsForCall[i].filename
}

func (fake *FakeIClient) HasAssetReturns(result1 bool, result2 error) {
	fake.HasAssetStub = nil
	fake.hasAssetReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) HasAssetReturnsOnCall(i int, result1 bool, result2 error) {
	fake.HasAssetStub = nil
	if fake.hasAssetReturnsOnCall == nil {
		fake.hasAssetReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasAssetReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) LoadAsset(filename string) ([]byte, error) {
	fake.loadAssetMutex.Lock()
	ret, specificReturn := fake.loadAssetReturnsOnCall[len(fake.loadAssetArgsForCall)]
	fake.loadAssetArgsForCall = append(fake.loadAssetArgsForCall, struct {
		filename string
	}{filename})
	fake.recordInvocation("LoadAsset", []interface{}{filename})
	fake.loadAssetMutex.Unlock()
	if fake.LoadAssetStub != nil {
		return fake.LoadAssetStub(filename)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.loadAssetReturns.result1, fake.loadAssetReturns.result2
}

func (fake *FakeIClient) LoadAssetCallCount() int {
	fake.loadAssetMutex.RLock()
	defer fake.loadAssetMutex.RUnlock()
	return len(fake.loadAssetArgsForCall)
}

func (fake *FakeIClient) LoadAssetArgsForCall(i int) string {
	fake.loadAssetMutex.RLock()
	defer fake.loadAssetMutex.RUnlock()
	return fake.loadAssetArgsForCall[i].filename
}

func (fake *FakeIClient) LoadAssetReturns(result1 []byte, result2 error) {
	fake.LoadAssetStub = nil
	fake.loadAssetReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) LoadAssetReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.LoadAssetStub = nil
	if fake.loadAssetReturnsOnCall == nil {
		fake.loadAssetReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.loadAssetReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) DeleteAsset(filename string) error {
	fake.deleteAssetMutex.Lock()
	ret, specificReturn := fake.deleteAssetReturnsOnCall[len(fake.deleteAssetArgsForCall)]
	fake.deleteAssetArgsForCall = append(fake.deleteAssetArgsForCall, struct {
		filename string
	}{filename})
	fake.recordInvocation("DeleteAsset", []interface{}{filename})
	fake.deleteAssetMutex.Unlock()
	if fake.DeleteAssetStub != nil {
		return fake.DeleteAssetStub(filename)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteAssetReturns.result1
}

func (fake *FakeIClient) DeleteAssetCallCount() int {
	fake.deleteAssetMutex.RLock()
	defer fake.deleteAssetMutex.RUnlock()
	return len(fake.deleteAssetArgsForCall)
}

func (fake *FakeIClient) DeleteAssetArgsForCall(i int) string {
	fake.deleteAssetMutex.RLock()
	defer fake.deleteAssetMutex.RUnlock()
	return fake.deleteAssetArgsForCall[i].filename
}

func (fake *FakeIClient) DeleteAssetReturns(result1 error) {
	fake.DeleteAssetStub = nil
	fake.deleteAssetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteAssetReturnsOnCall(i int, result1 error) {
	fake.DeleteAssetStub = nil
	if fake.deleteAssetReturnsOnCall == nil {
		fake.deleteAssetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAssetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.loadMutex.RLock()
	defer fake.loadMutex.RUnlock()
	fake.deleteAllMutex.RLock()
	defer fake.deleteAllMutex.RUnlock()
	fake.loadOrCreateMutex.RLock()
	defer fake.loadOrCreateMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.storeAssetMutex.RLock()
	defer fake.storeAssetMutex.RUnlock()
	fake.hasAssetMutex.RLock()
	defer fake.hasAssetMutex.RUnlock()
	fake.loadAssetMutex.RLock()
	defer fake.loadAssetMutex.RUnlock()
	fake.deleteAssetMutex.RLock()
	defer fake.deleteAssetMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ config.IClient = new(FakeIClient)
